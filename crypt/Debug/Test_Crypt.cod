; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\windows\belial\crypt\Test_Crypt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_pem_array DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02bH
	DB	02fH
_DATA	ENDS
PUBLIC	??_C@_0BB@KMHIJBEJ@RIJNDAEL?3?$CFs?0?$CFs?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0M@FLNGINMI@RC6?3?$CFs?0?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0M@LAOBDGML@RC5?3?$CFs?0?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0P@KIHJKIBO@CRC64?9abc?3?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0P@NIGPBFEN@CRC32?9abc?3?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0O@IFJLMJNL@Sha1?9abc?3?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0N@JOCEDPFE@MD5?9abc?3?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0M@PKFBIINI@Base64?3?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0BF@FFMPFMPG@Blowfish?5BCB?3?$CFs?0?$CFs?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0O@GMLPHOJC@XXTea?3?$CFs?0?$CFs?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0N@KGCCJEHM@XTea?3?$CFs?0?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0M@IBAKPAIN@Tea?3?$CFs?0?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0BA@OFBMLNBN@Des?5ECB?3?$CFs?0?$CFs?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@JBIEFEJC@Des?5BCB?3?$CFs?0?$CFs?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_07MFNHJMP@why0603?$AA@			; `string'
PUBLIC	??_C@_0CF@PNNFAAJL@abc?N?R?$LK?$LA?D?c?D?X123?D?c?T?u?C?$LE?$LO?M?C?$LL?S?P?L?$PN?$LF?$LN?D?X@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_main
EXTRN	__imp__getchar:PROC
EXTRN	_RijndaelDecrypt:PROC
EXTRN	_RijndaelEncrypt:PROC
EXTRN	_RijndaelInit:PROC
EXTRN	_RCDestroy:PROC
EXTRN	_RCDecrypt:PROC
EXTRN	_RCEncrypt:PROC
EXTRN	_RCInit:PROC
EXTRN	_GenCrc64:PROC
EXTRN	_Int2HexStr:PROC
EXTRN	_GenCrc32:PROC
EXTRN	_ShaFinal:PROC
EXTRN	_ShaUpdate:PROC
EXTRN	_ShaInit:PROC
EXTRN	_MD5Final:PROC
EXTRN	_MD5Update:PROC
EXTRN	_MD5Init:PROC
EXTRN	_Base64Decrypt:PROC
EXTRN	_Base64Encrypt:PROC
EXTRN	_BlowFishDecrypt:PROC
EXTRN	_BlowFishEncrypt:PROC
EXTRN	_BlowFishInit:PROC
EXTRN	_TeaDecrypt:PROC
EXTRN	_TeaEncrypt:PROC
EXTRN	_TeaSetKey:PROC
EXTRN	_TeaInit:PROC
EXTRN	_memset:PROC
EXTRN	__imp__printf:PROC
EXTRN	_DesDecrypt:PROC
EXTRN	_Byte2Hex:PROC
EXTRN	_DesEncrypt:PROC
EXTRN	_DesInit:PROC
EXTRN	_strcpy:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__chkstk:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	_memset:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT ??_C@_0BB@KMHIJBEJ@RIJNDAEL?3?$CFs?0?$CFs?$AN?6?$AA@
; File d:\windows\belial\crypt\test_crypt.c
CONST	SEGMENT
??_C@_0BB@KMHIJBEJ@RIJNDAEL?3?$CFs?0?$CFs?$AN?6?$AA@ DB 'RIJNDAEL:%s,%s', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FLNGINMI@RC6?3?$CFs?0?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0M@FLNGINMI@RC6?3?$CFs?0?$CFs?$AN?6?$AA@ DB 'RC6:%s,%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LAOBDGML@RC5?3?$CFs?0?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0M@LAOBDGML@RC5?3?$CFs?0?$CFs?$AN?6?$AA@ DB 'RC5:%s,%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KIHJKIBO@CRC64?9abc?3?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0P@KIHJKIBO@CRC64?9abc?3?$CFs?$AN?6?$AA@ DB 'CRC64-abc:%s', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NIGPBFEN@CRC32?9abc?3?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0P@NIGPBFEN@CRC32?9abc?3?$CFs?$AN?6?$AA@ DB 'CRC32-abc:%s', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFJLMJNL@Sha1?9abc?3?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0O@IFJLMJNL@Sha1?9abc?3?$CFs?$AN?6?$AA@ DB 'Sha1-abc:%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JOCEDPFE@MD5?9abc?3?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0N@JOCEDPFE@MD5?9abc?3?$CFs?$AN?6?$AA@ DB 'MD5-abc:%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PKFBIINI@Base64?3?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0M@PKFBIINI@Base64?3?$CFs?$AN?6?$AA@ DB 'Base64:%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FFMPFMPG@Blowfish?5BCB?3?$CFs?0?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BF@FFMPFMPG@Blowfish?5BCB?3?$CFs?0?$CFs?$AN?6?$AA@ DB 'Blowfish BC'
	DB	'B:%s,%s', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GMLPHOJC@XXTea?3?$CFs?0?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0O@GMLPHOJC@XXTea?3?$CFs?0?$CFs?$AN?6?$AA@ DB 'XXTea:%s,%s', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KGCCJEHM@XTea?3?$CFs?0?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0N@KGCCJEHM@XTea?3?$CFs?0?$CFs?$AN?6?$AA@ DB 'XTea:%s,%s', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IBAKPAIN@Tea?3?$CFs?0?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0M@IBAKPAIN@Tea?3?$CFs?0?$CFs?$AN?6?$AA@ DB 'Tea:%s,%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OFBMLNBN@Des?5ECB?3?$CFs?0?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BA@OFBMLNBN@Des?5ECB?3?$CFs?0?$CFs?$AN?6?$AA@ DB 'Des ECB:%s,%s', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JBIEFEJC@Des?5BCB?3?$CFs?0?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BA@JBIEFEJC@Des?5BCB?3?$CFs?0?$CFs?$AN?6?$AA@ DB 'Des BCB:%s,%s', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFNHJMP@why0603?$AA@
CONST	SEGMENT
??_C@_07MFNHJMP@why0603?$AA@ DB 'why0603', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PNNFAAJL@abc?N?R?$LK?$LA?D?c?D?X123?D?c?T?u?C?$LE?$LO?M?C?$LL?S?P?L?$PN?$LF?$LN?D?X@
CONST	SEGMENT
??_C@_0CF@PNNFAAJL@abc?N?R?$LK?$LA?D?c?D?X123?D?c?T?u?C?$LE?$LO?M?C?$LL?S?P?L?$PN?$LF?$LN?D?X@ DB 'a'
	DB	'bc', 0ceH, 0d2H, 0baH, 0b0H, 0c4H, 0e3H, 0c4H, 0d8H, '123', 0c4H
	DB	0e3H, 0d4H, 0f5H, 0c3H, 0b4H, 0beH, 0cdH, 0c3H, 0bbH, 0d3H, 0d0H
	DB	0ccH, 0fdH, 0b5H, 0bdH, 0c4H, 0d8H, '!@#$', 00H ; `string'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _main
_TEXT	SEGMENT
tv492 = -9536						; size = 4
tv483 = -9536						; size = 4
tv454 = -9536						; size = 4
tv445 = -9536						; size = 4
tv166 = -9536						; size = 4
_cliper_len$ = -9336					; size = 4
_verb_len$ = -9324					; size = 4
_verb$ = -9312						; size = 4
_base64$ = -9300					; size = 1024
_cArr$ = -8268						; size = 4
_hexer$ = -8256						; size = 1024
_pliper$ = -7224					; size = 1024
_cliper$ = -6192					; size = 1024
_sum$ = -5160						; size = 4
_tea_ctx$ = -5148					; size = 20
_des_ctx$ = -5120					; size = 144
_bf_ctx$ = -4968					; size = 4180
_rd_ctx$ = -780						; size = 532
_rc_ctx$ = -240						; size = 36
_sha_ctx$ = -196					; size = 92
_md5_ctx$ = -96						; size = 88
__$ArrayPad$ = -4					; size = 4
_main	PROC						; COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 40 25 00 00	 mov	 eax, 9536		; 00002540H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8d bd c0 da ff
	ff		 lea	 edi, DWORD PTR [ebp-9536]
  00016	b9 50 09 00 00	 mov	 ecx, 2384		; 00000950H
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 61   : 	/*
; 62   : 	__int64 ov = 0xFFFFEEEEEFFFFFFF;//0x0123456789ABCDEF;
; 63   : 	__int64 key = 0x70726F6772316D;//0x133457799BBCDFF1;
; 64   : 	printf("%s\r\n","start...");
; 65   : 	PrintHexStr(ov);
; 66   : 	ov = EnCrypt(ov,key);
; 67   : 	printf("加密后:");
; 68   : 	PrintHexStr(ov);
; 69   : 	ov = DeCrypt(ov,key);
; 70   : 	printf("解密后:");
; 71   : 	PrintHexStr(ov);
; 72   : 	*/
; 73   : 	
; 74   : 	MD5Context md5_ctx = {0};

  0002c	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _md5_ctx$[ebp], 0
  00033	6a 54		 push	 84			; 00000054H
  00035	6a 00		 push	 0
  00037	8d 45 a4	 lea	 eax, DWORD PTR _md5_ctx$[ebp+4]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _memset
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 75   : 	ShaContext sha_ctx = {0};

  00043	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _sha_ctx$[ebp], 0
  0004d	6a 58		 push	 88			; 00000058H
  0004f	6a 00		 push	 0
  00051	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _sha_ctx$[ebp+4]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _memset
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 76   : 	RCContext rc_ctx = {0};

  00060	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _rc_ctx$[ebp], 0
  0006a	33 c0		 xor	 eax, eax
  0006c	89 85 14 ff ff
	ff		 mov	 DWORD PTR _rc_ctx$[ebp+4], eax
  00072	89 85 18 ff ff
	ff		 mov	 DWORD PTR _rc_ctx$[ebp+8], eax
  00078	89 85 1c ff ff
	ff		 mov	 DWORD PTR _rc_ctx$[ebp+12], eax
  0007e	89 85 20 ff ff
	ff		 mov	 DWORD PTR _rc_ctx$[ebp+16], eax
  00084	89 85 24 ff ff
	ff		 mov	 DWORD PTR _rc_ctx$[ebp+20], eax
  0008a	89 85 28 ff ff
	ff		 mov	 DWORD PTR _rc_ctx$[ebp+24], eax
  00090	89 85 2c ff ff
	ff		 mov	 DWORD PTR _rc_ctx$[ebp+28], eax
  00096	89 85 30 ff ff
	ff		 mov	 DWORD PTR _rc_ctx$[ebp+32], eax

; 77   : 	RijndaelContext rd_ctx = {0};

  0009c	c6 85 f4 fc ff
	ff 00		 mov	 BYTE PTR _rd_ctx$[ebp], 0
  000a3	68 13 02 00 00	 push	 531			; 00000213H
  000a8	6a 00		 push	 0
  000aa	8d 85 f5 fc ff
	ff		 lea	 eax, DWORD PTR _rd_ctx$[ebp+1]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 _memset
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 78   : 	BlowFishContext bf_ctx = {0};

  000b9	c7 85 98 ec ff
	ff 00 00 00 00	 mov	 DWORD PTR _bf_ctx$[ebp], 0
  000c3	68 50 10 00 00	 push	 4176			; 00001050H
  000c8	6a 00		 push	 0
  000ca	8d 85 9c ec ff
	ff		 lea	 eax, DWORD PTR _bf_ctx$[ebp+4]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _memset
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 79   : 	DesContext des_ctx = {0};

  000d9	c6 85 00 ec ff
	ff 00		 mov	 BYTE PTR _des_ctx$[ebp], 0
  000e0	68 8f 00 00 00	 push	 143			; 0000008fH
  000e5	6a 00		 push	 0
  000e7	8d 85 01 ec ff
	ff		 lea	 eax, DWORD PTR _des_ctx$[ebp+1]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 _memset
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 80   : 	TeaContext tea_ctx = {0};

  000f6	c7 85 e4 eb ff
	ff 00 00 00 00	 mov	 DWORD PTR _tea_ctx$[ebp], 0
  00100	33 c0		 xor	 eax, eax
  00102	89 85 e8 eb ff
	ff		 mov	 DWORD PTR _tea_ctx$[ebp+4], eax
  00108	89 85 ec eb ff
	ff		 mov	 DWORD PTR _tea_ctx$[ebp+8], eax
  0010e	89 85 f0 eb ff
	ff		 mov	 DWORD PTR _tea_ctx$[ebp+12], eax
  00114	89 85 f4 eb ff
	ff		 mov	 DWORD PTR _tea_ctx$[ebp+16], eax

; 81   : #ifdef RSA
; 82   : 	RsaContext rsa_ctx;
; 83   : 	RsaPublicKey publicKey;
; 84   : 	RsaPrivateKey privateKey;
; 85   : 	RsaElement rsaElement;
; 86   : #endif
; 87   : 	unsigned int sum=0;

  0011a	c7 85 d8 eb ff
	ff 00 00 00 00	 mov	 DWORD PTR _sum$[ebp], 0

; 88   : 	char cliper[CLIPERLEN] = {0};

  00124	c6 85 d0 e7 ff
	ff 00		 mov	 BYTE PTR _cliper$[ebp], 0
  0012b	68 ff 03 00 00	 push	 1023			; 000003ffH
  00130	6a 00		 push	 0
  00132	8d 85 d1 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp+1]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _memset
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 89   : 	char pliper[CLIPERLEN] = {0};

  00141	c6 85 c8 e3 ff
	ff 00		 mov	 BYTE PTR _pliper$[ebp], 0
  00148	68 ff 03 00 00	 push	 1023			; 000003ffH
  0014d	6a 00		 push	 0
  0014f	8d 85 c9 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp+1]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 _memset
  0015b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 90   : 	char hexer[CLIPERLEN] = {0};

  0015e	c6 85 c0 df ff
	ff 00		 mov	 BYTE PTR _hexer$[ebp], 0
  00165	68 ff 03 00 00	 push	 1023			; 000003ffH
  0016a	6a 00		 push	 0
  0016c	8d 85 c1 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp+1]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _memset
  00178	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   : 	char cArr[4] = {0x12,0x34,0x56,0x78};

  0017b	c6 85 b4 df ff
	ff 12		 mov	 BYTE PTR _cArr$[ebp], 18 ; 00000012H
  00182	c6 85 b5 df ff
	ff 34		 mov	 BYTE PTR _cArr$[ebp+1], 52 ; 00000034H
  00189	c6 85 b6 df ff
	ff 56		 mov	 BYTE PTR _cArr$[ebp+2], 86 ; 00000056H
  00190	c6 85 b7 df ff
	ff 78		 mov	 BYTE PTR _cArr$[ebp+3], 120 ; 00000078H

; 92   : 	int base64[256] = {0};

  00197	c7 85 ac db ff
	ff 00 00 00 00	 mov	 DWORD PTR _base64$[ebp], 0
  001a1	68 fc 03 00 00	 push	 1020			; 000003fcH
  001a6	6a 00		 push	 0
  001a8	8d 85 b0 db ff
	ff		 lea	 eax, DWORD PTR _base64$[ebp+4]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 _memset
  001b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 93   : 	char* verb = "abc我喊你呢123你怎么就没有听到呢!@#$";

  001b7	c7 85 a0 db ff
	ff 00 00 00 00	 mov	 DWORD PTR _verb$[ebp], OFFSET ??_C@_0CF@PNNFAAJL@abc?N?R?$LK?$LA?D?c?D?X123?D?c?T?u?C?$LE?$LO?M?C?$LL?S?P?L?$PN?$LF?$LN?D?X@

; 94   : 	unsigned int verb_len = 36;

  001c1	c7 85 94 db ff
	ff 24 00 00 00	 mov	 DWORD PTR _verb_len$[ebp], 36 ; 00000024H

; 95   : 	unsigned int cliper_len = CHECKDIV8(verb_len);//RC6不是使用这个算法

  001cb	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  001d1	83 e0 07	 and	 eax, 7
  001d4	74 1c		 je	 SHORT $LN3@main
  001d6	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  001dc	83 c1 08	 add	 ecx, 8
  001df	8b 95 94 db ff
	ff		 mov	 edx, DWORD PTR _verb_len$[ebp]
  001e5	83 e2 07	 and	 edx, 7
  001e8	2b ca		 sub	 ecx, edx
  001ea	89 8d c0 da ff
	ff		 mov	 DWORD PTR tv166[ebp], ecx
  001f0	eb 0c		 jmp	 SHORT $LN4@main
$LN3@main:
  001f2	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  001f8	89 85 c0 da ff
	ff		 mov	 DWORD PTR tv166[ebp], eax
$LN4@main:
  001fe	8b 8d c0 da ff
	ff		 mov	 ecx, DWORD PTR tv166[ebp]
  00204	89 8d 88 db ff
	ff		 mov	 DWORD PTR _cliper_len$[ebp], ecx

; 96   : 	//DesInit("why0603",7);
; 97   : 	//TeaInit("why0603",7);
; 98   : 	//BlowFishInit("why0603",7);
; 99   : 
; 100  : 	rc_ctx.pKey = (unsigned char*)"why0603";

  0020a	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _rc_ctx$[ebp+12], OFFSET ??_C@_07MFNHJMP@why0603?$AA@

; 101  : 	rc_ctx.nKeyLen = 7;

  00214	c7 85 20 ff ff
	ff 07 00 00 00	 mov	 DWORD PTR _rc_ctx$[ebp+16], 7

; 102  : 	rc_ctx.nRound = 20;

  0021e	c7 85 14 ff ff
	ff 14 00 00 00	 mov	 DWORD PTR _rc_ctx$[ebp+4], 20 ; 00000014H

; 103  : 	strcpy((char*)rd_ctx.cryptKey,"why0603");

  00228	68 00 00 00 00	 push	 OFFSET ??_C@_07MFNHJMP@why0603?$AA@
  0022d	8d 85 f4 fc ff
	ff		 lea	 eax, DWORD PTR _rd_ctx$[ebp]
  00233	50		 push	 eax
  00234	e8 00 00 00 00	 call	 _strcpy
  00239	83 c4 08	 add	 esp, 8

; 104  : 
; 105  : 	//DES
; 106  : 	strcpy((char*)des_ctx.key,"why0603");

  0023c	68 00 00 00 00	 push	 OFFSET ??_C@_07MFNHJMP@why0603?$AA@
  00241	8d 85 00 ec ff
	ff		 lea	 eax, DWORD PTR _des_ctx$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 _strcpy
  0024d	83 c4 08	 add	 esp, 8

; 107  : 	des_ctx.mode = Des_Mode_BCB;

  00250	c7 85 88 ec ff
	ff 01 00 00 00	 mov	 DWORD PTR _des_ctx$[ebp+136], 1

; 108  : 
; 109  : 	DesInit(&des_ctx);

  0025a	8d 85 00 ec ff
	ff		 lea	 eax, DWORD PTR _des_ctx$[ebp]
  00260	50		 push	 eax
  00261	e8 00 00 00 00	 call	 _DesInit
  00266	83 c4 04	 add	 esp, 4

; 110  : 	DesEncrypt(&des_ctx,verb,verb_len,cliper);//Des_Mode_BCB

  00269	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  0026f	50		 push	 eax
  00270	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  00276	51		 push	 ecx
  00277	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  0027d	52		 push	 edx
  0027e	8d 85 00 ec ff
	ff		 lea	 eax, DWORD PTR _des_ctx$[ebp]
  00284	50		 push	 eax
  00285	e8 00 00 00 00	 call	 _DesEncrypt
  0028a	83 c4 10	 add	 esp, 16			; 00000010H

; 111  : 	Byte2Hex((unsigned char*)cliper,hexer,verb_len,0);

  0028d	6a 00		 push	 0
  0028f	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00295	50		 push	 eax
  00296	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  0029c	51		 push	 ecx
  0029d	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  002a3	52		 push	 edx
  002a4	e8 00 00 00 00	 call	 _Byte2Hex
  002a9	83 c4 10	 add	 esp, 16			; 00000010H

; 112  : 	DesDecrypt(&des_ctx,cliper,cliper_len,pliper);

  002ac	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  002b2	50		 push	 eax
  002b3	8b 8d 88 db ff
	ff		 mov	 ecx, DWORD PTR _cliper_len$[ebp]
  002b9	51		 push	 ecx
  002ba	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  002c0	52		 push	 edx
  002c1	8d 85 00 ec ff
	ff		 lea	 eax, DWORD PTR _des_ctx$[ebp]
  002c7	50		 push	 eax
  002c8	e8 00 00 00 00	 call	 _DesDecrypt
  002cd	83 c4 10	 add	 esp, 16			; 00000010H

; 113  : 	printf("Des BCB:%s,%s\r\n",hexer,pliper);

  002d0	8b f4		 mov	 esi, esp
  002d2	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  002d8	50		 push	 eax
  002d9	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  002df	51		 push	 ecx
  002e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JBIEFEJC@Des?5BCB?3?$CFs?0?$CFs?$AN?6?$AA@
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  002eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ee	3b f4		 cmp	 esi, esp
  002f0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 114  : 	memset(cliper,0,CLIPERLEN);

  002f5	68 00 04 00 00	 push	 1024			; 00000400H
  002fa	6a 00		 push	 0
  002fc	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00302	50		 push	 eax
  00303	e8 00 00 00 00	 call	 _memset
  00308	83 c4 0c	 add	 esp, 12			; 0000000cH

; 115  : 	memset(pliper,0,CLIPERLEN);

  0030b	68 00 04 00 00	 push	 1024			; 00000400H
  00310	6a 00		 push	 0
  00312	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00318	50		 push	 eax
  00319	e8 00 00 00 00	 call	 _memset
  0031e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 116  : 	memset(hexer,0,CLIPERLEN);

  00321	68 00 04 00 00	 push	 1024			; 00000400H
  00326	6a 00		 push	 0
  00328	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  0032e	50		 push	 eax
  0032f	e8 00 00 00 00	 call	 _memset
  00334	83 c4 0c	 add	 esp, 12			; 0000000cH

; 117  : 
; 118  : 	//DES
; 119  : 	des_ctx.mode = Des_Mode_ECB;

  00337	c7 85 88 ec ff
	ff 00 00 00 00	 mov	 DWORD PTR _des_ctx$[ebp+136], 0

; 120  : 	DesEncrypt(&des_ctx,verb,verb_len,cliper);//Des_Mode_BCB

  00341	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00347	50		 push	 eax
  00348	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  0034e	51		 push	 ecx
  0034f	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  00355	52		 push	 edx
  00356	8d 85 00 ec ff
	ff		 lea	 eax, DWORD PTR _des_ctx$[ebp]
  0035c	50		 push	 eax
  0035d	e8 00 00 00 00	 call	 _DesEncrypt
  00362	83 c4 10	 add	 esp, 16			; 00000010H

; 121  : 	Byte2Hex((unsigned char*)cliper,hexer,verb_len,0);

  00365	6a 00		 push	 0
  00367	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  0036d	50		 push	 eax
  0036e	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  00374	51		 push	 ecx
  00375	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  0037b	52		 push	 edx
  0037c	e8 00 00 00 00	 call	 _Byte2Hex
  00381	83 c4 10	 add	 esp, 16			; 00000010H

; 122  : 	DesDecrypt(&des_ctx,cliper,cliper_len,pliper);

  00384	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  0038a	50		 push	 eax
  0038b	8b 8d 88 db ff
	ff		 mov	 ecx, DWORD PTR _cliper_len$[ebp]
  00391	51		 push	 ecx
  00392	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  00398	52		 push	 edx
  00399	8d 85 00 ec ff
	ff		 lea	 eax, DWORD PTR _des_ctx$[ebp]
  0039f	50		 push	 eax
  003a0	e8 00 00 00 00	 call	 _DesDecrypt
  003a5	83 c4 10	 add	 esp, 16			; 00000010H

; 123  : 	printf("Des ECB:%s,%s\r\n",hexer,pliper);

  003a8	8b f4		 mov	 esi, esp
  003aa	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  003b0	50		 push	 eax
  003b1	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  003b7	51		 push	 ecx
  003b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OFBMLNBN@Des?5ECB?3?$CFs?0?$CFs?$AN?6?$AA@
  003bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  003c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c6	3b f4		 cmp	 esi, esp
  003c8	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 124  : 	memset(cliper,0,CLIPERLEN);

  003cd	68 00 04 00 00	 push	 1024			; 00000400H
  003d2	6a 00		 push	 0
  003d4	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  003da	50		 push	 eax
  003db	e8 00 00 00 00	 call	 _memset
  003e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 125  : 	memset(pliper,0,CLIPERLEN);

  003e3	68 00 04 00 00	 push	 1024			; 00000400H
  003e8	6a 00		 push	 0
  003ea	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  003f0	50		 push	 eax
  003f1	e8 00 00 00 00	 call	 _memset
  003f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 126  : 	memset(hexer,0,CLIPERLEN);

  003f9	68 00 04 00 00	 push	 1024			; 00000400H
  003fe	6a 00		 push	 0
  00400	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  00406	50		 push	 eax
  00407	e8 00 00 00 00	 call	 _memset
  0040c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 127  : 
; 128  : 	//TEA
; 129  : 	TeaInit(&tea_ctx);

  0040f	8d 85 e4 eb ff
	ff		 lea	 eax, DWORD PTR _tea_ctx$[ebp]
  00415	50		 push	 eax
  00416	e8 00 00 00 00	 call	 _TeaInit
  0041b	83 c4 04	 add	 esp, 4

; 130  : 	tea_ctx.mode = Tea_Mode;

  0041e	c7 85 f4 eb ff
	ff 00 00 00 00	 mov	 DWORD PTR _tea_ctx$[ebp+16], 0

; 131  : 	TeaSetKey(&tea_ctx,"why0603",7);

  00428	6a 07		 push	 7
  0042a	68 00 00 00 00	 push	 OFFSET ??_C@_07MFNHJMP@why0603?$AA@
  0042f	8d 85 e4 eb ff
	ff		 lea	 eax, DWORD PTR _tea_ctx$[ebp]
  00435	50		 push	 eax
  00436	e8 00 00 00 00	 call	 _TeaSetKey
  0043b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 132  : 	TeaEncrypt(&tea_ctx,verb,verb_len,cliper);//Tea_Mode_Tea

  0043e	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00444	50		 push	 eax
  00445	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  0044b	51		 push	 ecx
  0044c	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  00452	52		 push	 edx
  00453	8d 85 e4 eb ff
	ff		 lea	 eax, DWORD PTR _tea_ctx$[ebp]
  00459	50		 push	 eax
  0045a	e8 00 00 00 00	 call	 _TeaEncrypt
  0045f	83 c4 10	 add	 esp, 16			; 00000010H

; 133  : 	Byte2Hex((unsigned char*)cliper,hexer,verb_len,0);

  00462	6a 00		 push	 0
  00464	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  0046a	50		 push	 eax
  0046b	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  00471	51		 push	 ecx
  00472	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  00478	52		 push	 edx
  00479	e8 00 00 00 00	 call	 _Byte2Hex
  0047e	83 c4 10	 add	 esp, 16			; 00000010H

; 134  : 	TeaDecrypt(&tea_ctx,cliper,cliper_len,pliper);

  00481	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00487	50		 push	 eax
  00488	8b 8d 88 db ff
	ff		 mov	 ecx, DWORD PTR _cliper_len$[ebp]
  0048e	51		 push	 ecx
  0048f	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  00495	52		 push	 edx
  00496	8d 85 e4 eb ff
	ff		 lea	 eax, DWORD PTR _tea_ctx$[ebp]
  0049c	50		 push	 eax
  0049d	e8 00 00 00 00	 call	 _TeaDecrypt
  004a2	83 c4 10	 add	 esp, 16			; 00000010H

; 135  : 	printf("Tea:%s,%s\r\n",hexer,pliper);

  004a5	8b f4		 mov	 esi, esp
  004a7	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  004ad	50		 push	 eax
  004ae	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  004b4	51		 push	 ecx
  004b5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IBAKPAIN@Tea?3?$CFs?0?$CFs?$AN?6?$AA@
  004ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  004c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c3	3b f4		 cmp	 esi, esp
  004c5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 136  : 	memset(cliper,0,CLIPERLEN);

  004ca	68 00 04 00 00	 push	 1024			; 00000400H
  004cf	6a 00		 push	 0
  004d1	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  004d7	50		 push	 eax
  004d8	e8 00 00 00 00	 call	 _memset
  004dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 137  : 	memset(pliper,0,CLIPERLEN);

  004e0	68 00 04 00 00	 push	 1024			; 00000400H
  004e5	6a 00		 push	 0
  004e7	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  004ed	50		 push	 eax
  004ee	e8 00 00 00 00	 call	 _memset
  004f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 138  : 	memset(hexer,0,CLIPERLEN);

  004f6	68 00 04 00 00	 push	 1024			; 00000400H
  004fb	6a 00		 push	 0
  004fd	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  00503	50		 push	 eax
  00504	e8 00 00 00 00	 call	 _memset
  00509	83 c4 0c	 add	 esp, 12			; 0000000cH

; 139  : 
; 140  : 	//XTEA
; 141  : 	tea_ctx.mode = XTea_Mode;

  0050c	c7 85 f4 eb ff
	ff 01 00 00 00	 mov	 DWORD PTR _tea_ctx$[ebp+16], 1

; 142  : 	TeaEncrypt(&tea_ctx,verb,verb_len,cliper);//Tea_Mode_Tea

  00516	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  0051c	50		 push	 eax
  0051d	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  00523	51		 push	 ecx
  00524	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  0052a	52		 push	 edx
  0052b	8d 85 e4 eb ff
	ff		 lea	 eax, DWORD PTR _tea_ctx$[ebp]
  00531	50		 push	 eax
  00532	e8 00 00 00 00	 call	 _TeaEncrypt
  00537	83 c4 10	 add	 esp, 16			; 00000010H

; 143  : 	Byte2Hex((unsigned char*)cliper,hexer,verb_len,0);

  0053a	6a 00		 push	 0
  0053c	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00542	50		 push	 eax
  00543	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  00549	51		 push	 ecx
  0054a	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  00550	52		 push	 edx
  00551	e8 00 00 00 00	 call	 _Byte2Hex
  00556	83 c4 10	 add	 esp, 16			; 00000010H

; 144  : 	TeaDecrypt(&tea_ctx,cliper,cliper_len,pliper);

  00559	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  0055f	50		 push	 eax
  00560	8b 8d 88 db ff
	ff		 mov	 ecx, DWORD PTR _cliper_len$[ebp]
  00566	51		 push	 ecx
  00567	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  0056d	52		 push	 edx
  0056e	8d 85 e4 eb ff
	ff		 lea	 eax, DWORD PTR _tea_ctx$[ebp]
  00574	50		 push	 eax
  00575	e8 00 00 00 00	 call	 _TeaDecrypt
  0057a	83 c4 10	 add	 esp, 16			; 00000010H

; 145  : 	printf("XTea:%s,%s\r\n",hexer,pliper);

  0057d	8b f4		 mov	 esi, esp
  0057f	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00585	50		 push	 eax
  00586	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  0058c	51		 push	 ecx
  0058d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KGCCJEHM@XTea?3?$CFs?0?$CFs?$AN?6?$AA@
  00592	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00598	83 c4 0c	 add	 esp, 12			; 0000000cH
  0059b	3b f4		 cmp	 esi, esp
  0059d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 146  : 	memset(cliper,0,CLIPERLEN);

  005a2	68 00 04 00 00	 push	 1024			; 00000400H
  005a7	6a 00		 push	 0
  005a9	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  005af	50		 push	 eax
  005b0	e8 00 00 00 00	 call	 _memset
  005b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 147  : 	memset(pliper,0,CLIPERLEN);

  005b8	68 00 04 00 00	 push	 1024			; 00000400H
  005bd	6a 00		 push	 0
  005bf	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  005c5	50		 push	 eax
  005c6	e8 00 00 00 00	 call	 _memset
  005cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 148  : 	memset(hexer,0,CLIPERLEN);

  005ce	68 00 04 00 00	 push	 1024			; 00000400H
  005d3	6a 00		 push	 0
  005d5	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  005db	50		 push	 eax
  005dc	e8 00 00 00 00	 call	 _memset
  005e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  : 
; 150  : 	//XXTEA
; 151  : 	tea_ctx.mode = XXTea_Mode;

  005e4	c7 85 f4 eb ff
	ff 02 00 00 00	 mov	 DWORD PTR _tea_ctx$[ebp+16], 2

; 152  : 	TeaEncrypt(&tea_ctx,verb,verb_len,cliper);//Tea_Mode_Tea

  005ee	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  005f4	50		 push	 eax
  005f5	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  005fb	51		 push	 ecx
  005fc	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  00602	52		 push	 edx
  00603	8d 85 e4 eb ff
	ff		 lea	 eax, DWORD PTR _tea_ctx$[ebp]
  00609	50		 push	 eax
  0060a	e8 00 00 00 00	 call	 _TeaEncrypt
  0060f	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 	Byte2Hex((unsigned char*)cliper,hexer,verb_len,0);

  00612	6a 00		 push	 0
  00614	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  0061a	50		 push	 eax
  0061b	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  00621	51		 push	 ecx
  00622	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  00628	52		 push	 edx
  00629	e8 00 00 00 00	 call	 _Byte2Hex
  0062e	83 c4 10	 add	 esp, 16			; 00000010H

; 154  : 	TeaDecrypt(&tea_ctx,cliper,cliper_len,pliper);

  00631	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00637	50		 push	 eax
  00638	8b 8d 88 db ff
	ff		 mov	 ecx, DWORD PTR _cliper_len$[ebp]
  0063e	51		 push	 ecx
  0063f	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  00645	52		 push	 edx
  00646	8d 85 e4 eb ff
	ff		 lea	 eax, DWORD PTR _tea_ctx$[ebp]
  0064c	50		 push	 eax
  0064d	e8 00 00 00 00	 call	 _TeaDecrypt
  00652	83 c4 10	 add	 esp, 16			; 00000010H

; 155  : 	printf("XXTea:%s,%s\r\n",hexer,pliper);

  00655	8b f4		 mov	 esi, esp
  00657	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  0065d	50		 push	 eax
  0065e	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  00664	51		 push	 ecx
  00665	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GMLPHOJC@XXTea?3?$CFs?0?$CFs?$AN?6?$AA@
  0066a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00670	83 c4 0c	 add	 esp, 12			; 0000000cH
  00673	3b f4		 cmp	 esi, esp
  00675	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 156  : 	memset(cliper,0,CLIPERLEN);

  0067a	68 00 04 00 00	 push	 1024			; 00000400H
  0067f	6a 00		 push	 0
  00681	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00687	50		 push	 eax
  00688	e8 00 00 00 00	 call	 _memset
  0068d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 157  : 	memset(pliper,0,CLIPERLEN);

  00690	68 00 04 00 00	 push	 1024			; 00000400H
  00695	6a 00		 push	 0
  00697	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  0069d	50		 push	 eax
  0069e	e8 00 00 00 00	 call	 _memset
  006a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 158  : 	memset(hexer,0,CLIPERLEN);

  006a6	68 00 04 00 00	 push	 1024			; 00000400H
  006ab	6a 00		 push	 0
  006ad	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  006b3	50		 push	 eax
  006b4	e8 00 00 00 00	 call	 _memset
  006b9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  : 
; 160  : 	/*
; 161  : 	//BLOWFISH
; 162  : 	BlowFishEncrypt(verb,verb_len,cliper,BF_Mode_BCB);//BF_Mode_ECB
; 163  : 	Byte2Hex((unsigned char*)cliper,hexer,verb_len,0);
; 164  : 	BlowFishDecrypt(cliper,cliper_len,pliper,BF_Mode_BCB);
; 165  : 	printf("Blowfish ECB:%s,%s\r\n",hexer,pliper);
; 166  : 	memset(cliper,0,CLIPERLEN);
; 167  : 	memset(pliper,0,CLIPERLEN);
; 168  : 	memset(hexer,0,CLIPERLEN);
; 169  : 
; 170  : 	//BLOWFISH
; 171  : 	BlowFishEncrypt(verb,verb_len,cliper,BF_Mode_ECB);//BF_Mode_ECB
; 172  : 	Byte2Hex((unsigned char*)cliper,hexer,verb_len,0);
; 173  : 	BlowFishDecrypt(cliper,cliper_len,pliper,BF_Mode_ECB);
; 174  : 	printf("Blowfish BCB:%s,%s\r\n",hexer,pliper);
; 175  : 	memset(cliper,0,CLIPERLEN);
; 176  : 	memset(pliper,0,CLIPERLEN);
; 177  : 	memset(hexer,0,CLIPERLEN);
; 178  : 	*/
; 179  : 	bf_ctx.pKey = (char*)"why0603";

  006bc	c7 85 98 ec ff
	ff 00 00 00 00	 mov	 DWORD PTR _bf_ctx$[ebp], OFFSET ??_C@_07MFNHJMP@why0603?$AA@

; 180  : 	bf_ctx.nLen = 7;

  006c6	c7 85 9c ec ff
	ff 07 00 00 00	 mov	 DWORD PTR _bf_ctx$[ebp+4], 7

; 181  : 	bf_ctx.mode = BF_Mode_BCB;

  006d0	c7 85 e8 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _bf_ctx$[ebp+4176], 1

; 182  : 	BlowFishInit(&bf_ctx);

  006da	8d 85 98 ec ff
	ff		 lea	 eax, DWORD PTR _bf_ctx$[ebp]
  006e0	50		 push	 eax
  006e1	e8 00 00 00 00	 call	 _BlowFishInit
  006e6	83 c4 04	 add	 esp, 4

; 183  : 	BlowFishEncrypt(&bf_ctx,verb,verb_len,cliper);

  006e9	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  006ef	50		 push	 eax
  006f0	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  006f6	51		 push	 ecx
  006f7	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  006fd	52		 push	 edx
  006fe	8d 85 98 ec ff
	ff		 lea	 eax, DWORD PTR _bf_ctx$[ebp]
  00704	50		 push	 eax
  00705	e8 00 00 00 00	 call	 _BlowFishEncrypt
  0070a	83 c4 10	 add	 esp, 16			; 00000010H

; 184  : 	Byte2Hex((unsigned char*)cliper,hexer,verb_len,0);

  0070d	6a 00		 push	 0
  0070f	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00715	50		 push	 eax
  00716	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  0071c	51		 push	 ecx
  0071d	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  00723	52		 push	 edx
  00724	e8 00 00 00 00	 call	 _Byte2Hex
  00729	83 c4 10	 add	 esp, 16			; 00000010H

; 185  : 	BlowFishDecrypt(&bf_ctx,cliper,cliper_len,pliper);

  0072c	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00732	50		 push	 eax
  00733	8b 8d 88 db ff
	ff		 mov	 ecx, DWORD PTR _cliper_len$[ebp]
  00739	51		 push	 ecx
  0073a	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  00740	52		 push	 edx
  00741	8d 85 98 ec ff
	ff		 lea	 eax, DWORD PTR _bf_ctx$[ebp]
  00747	50		 push	 eax
  00748	e8 00 00 00 00	 call	 _BlowFishDecrypt
  0074d	83 c4 10	 add	 esp, 16			; 00000010H

; 186  : 	printf("Blowfish BCB:%s,%s\r\n",hexer,pliper);

  00750	8b f4		 mov	 esi, esp
  00752	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00758	50		 push	 eax
  00759	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  0075f	51		 push	 ecx
  00760	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FFMPFMPG@Blowfish?5BCB?3?$CFs?0?$CFs?$AN?6?$AA@
  00765	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0076b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0076e	3b f4		 cmp	 esi, esp
  00770	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 187  : 	memset(cliper,0,CLIPERLEN);

  00775	68 00 04 00 00	 push	 1024			; 00000400H
  0077a	6a 00		 push	 0
  0077c	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00782	50		 push	 eax
  00783	e8 00 00 00 00	 call	 _memset
  00788	83 c4 0c	 add	 esp, 12			; 0000000cH

; 188  : 	memset(pliper,0,CLIPERLEN);

  0078b	68 00 04 00 00	 push	 1024			; 00000400H
  00790	6a 00		 push	 0
  00792	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00798	50		 push	 eax
  00799	e8 00 00 00 00	 call	 _memset
  0079e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 189  : 	memset(hexer,0,CLIPERLEN);

  007a1	68 00 04 00 00	 push	 1024			; 00000400H
  007a6	6a 00		 push	 0
  007a8	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  007ae	50		 push	 eax
  007af	e8 00 00 00 00	 call	 _memset
  007b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 190  : 
; 191  : 	//BASE64
; 192  : 	sum = Base64Encrypt((unsigned char*)verb,verb_len,(unsigned char*)pliper,Base64_Mode_PEM);

  007b7	6a 00		 push	 0
  007b9	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  007bf	50		 push	 eax
  007c0	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  007c6	51		 push	 ecx
  007c7	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  007cd	52		 push	 edx
  007ce	e8 00 00 00 00	 call	 _Base64Encrypt
  007d3	83 c4 10	 add	 esp, 16			; 00000010H
  007d6	89 85 d8 eb ff
	ff		 mov	 DWORD PTR _sum$[ebp], eax

; 193  : 	printf("Base64:%s\r\n",pliper);

  007dc	8b f4		 mov	 esi, esp
  007de	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  007e4	50		 push	 eax
  007e5	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PKFBIINI@Base64?3?$CFs?$AN?6?$AA@
  007ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  007f0	83 c4 08	 add	 esp, 8
  007f3	3b f4		 cmp	 esi, esp
  007f5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 194  : 	sum = Base64Decrypt((unsigned char*)pliper,sum,(unsigned char*)cliper,Base64_Mode_PEM);

  007fa	6a 00		 push	 0
  007fc	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00802	50		 push	 eax
  00803	8b 8d d8 eb ff
	ff		 mov	 ecx, DWORD PTR _sum$[ebp]
  00809	51		 push	 ecx
  0080a	8d 95 c8 e3 ff
	ff		 lea	 edx, DWORD PTR _pliper$[ebp]
  00810	52		 push	 edx
  00811	e8 00 00 00 00	 call	 _Base64Decrypt
  00816	83 c4 10	 add	 esp, 16			; 00000010H
  00819	89 85 d8 eb ff
	ff		 mov	 DWORD PTR _sum$[ebp], eax

; 195  : 	printf("Base64:%s\r\n",cliper);

  0081f	8b f4		 mov	 esi, esp
  00821	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00827	50		 push	 eax
  00828	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PKFBIINI@Base64?3?$CFs?$AN?6?$AA@
  0082d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00833	83 c4 08	 add	 esp, 8
  00836	3b f4		 cmp	 esi, esp
  00838	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 196  : 	memset(cliper,0,CLIPERLEN);

  0083d	68 00 04 00 00	 push	 1024			; 00000400H
  00842	6a 00		 push	 0
  00844	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  0084a	50		 push	 eax
  0084b	e8 00 00 00 00	 call	 _memset
  00850	83 c4 0c	 add	 esp, 12			; 0000000cH

; 197  : 	memset(pliper,0,CLIPERLEN);

  00853	68 00 04 00 00	 push	 1024			; 00000400H
  00858	6a 00		 push	 0
  0085a	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00860	50		 push	 eax
  00861	e8 00 00 00 00	 call	 _memset
  00866	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  : 
; 199  : 	//MD5算法
; 200  : 	MD5Init(&md5_ctx);

  00869	8d 45 a0	 lea	 eax, DWORD PTR _md5_ctx$[ebp]
  0086c	50		 push	 eax
  0086d	e8 00 00 00 00	 call	 _MD5Init
  00872	83 c4 04	 add	 esp, 4

; 201  : 	MD5Update(&md5_ctx,(unsigned char*)verb,verb_len);

  00875	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  0087b	50		 push	 eax
  0087c	8b 8d a0 db ff
	ff		 mov	 ecx, DWORD PTR _verb$[ebp]
  00882	51		 push	 ecx
  00883	8d 55 a0	 lea	 edx, DWORD PTR _md5_ctx$[ebp]
  00886	52		 push	 edx
  00887	e8 00 00 00 00	 call	 _MD5Update
  0088c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  : 	MD5Final(&md5_ctx,(unsigned char*)cliper);

  0088f	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00895	50		 push	 eax
  00896	8d 4d a0	 lea	 ecx, DWORD PTR _md5_ctx$[ebp]
  00899	51		 push	 ecx
  0089a	e8 00 00 00 00	 call	 _MD5Final
  0089f	83 c4 08	 add	 esp, 8

; 203  : 	Byte2Hex((unsigned char*)cliper,hexer,16,0);

  008a2	6a 00		 push	 0
  008a4	6a 10		 push	 16			; 00000010H
  008a6	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  008ac	50		 push	 eax
  008ad	8d 8d d0 e7 ff
	ff		 lea	 ecx, DWORD PTR _cliper$[ebp]
  008b3	51		 push	 ecx
  008b4	e8 00 00 00 00	 call	 _Byte2Hex
  008b9	83 c4 10	 add	 esp, 16			; 00000010H

; 204  : 	printf("MD5-abc:%s\r\n",hexer);

  008bc	8b f4		 mov	 esi, esp
  008be	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  008c4	50		 push	 eax
  008c5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JOCEDPFE@MD5?9abc?3?$CFs?$AN?6?$AA@
  008ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  008d0	83 c4 08	 add	 esp, 8
  008d3	3b f4		 cmp	 esi, esp
  008d5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 205  : 	memset(cliper,0,CLIPERLEN);

  008da	68 00 04 00 00	 push	 1024			; 00000400H
  008df	6a 00		 push	 0
  008e1	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  008e7	50		 push	 eax
  008e8	e8 00 00 00 00	 call	 _memset
  008ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 206  : 	memset(pliper,0,CLIPERLEN);

  008f0	68 00 04 00 00	 push	 1024			; 00000400H
  008f5	6a 00		 push	 0
  008f7	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  008fd	50		 push	 eax
  008fe	e8 00 00 00 00	 call	 _memset
  00903	83 c4 0c	 add	 esp, 12			; 0000000cH

; 207  : 	memset(hexer,0,CLIPERLEN);

  00906	68 00 04 00 00	 push	 1024			; 00000400H
  0090b	6a 00		 push	 0
  0090d	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  00913	50		 push	 eax
  00914	e8 00 00 00 00	 call	 _memset
  00919	83 c4 0c	 add	 esp, 12			; 0000000cH

; 208  : 
; 209  : 
; 210  : 	//SHA1-160算法
; 211  : 	ShaInit(&sha_ctx);

  0091c	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _sha_ctx$[ebp]
  00922	50		 push	 eax
  00923	e8 00 00 00 00	 call	 _ShaInit
  00928	83 c4 04	 add	 esp, 4

; 212  : 	ShaUpdate(&sha_ctx,(unsigned char*)verb,verb_len);

  0092b	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00931	50		 push	 eax
  00932	8b 8d a0 db ff
	ff		 mov	 ecx, DWORD PTR _verb$[ebp]
  00938	51		 push	 ecx
  00939	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR _sha_ctx$[ebp]
  0093f	52		 push	 edx
  00940	e8 00 00 00 00	 call	 _ShaUpdate
  00945	83 c4 0c	 add	 esp, 12			; 0000000cH

; 213  : 	ShaFinal(&sha_ctx,(unsigned char*)cliper);

  00948	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  0094e	50		 push	 eax
  0094f	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _sha_ctx$[ebp]
  00955	51		 push	 ecx
  00956	e8 00 00 00 00	 call	 _ShaFinal
  0095b	83 c4 08	 add	 esp, 8

; 214  : 	Byte2Hex((unsigned char*)cliper,hexer,20,0);

  0095e	6a 00		 push	 0
  00960	6a 14		 push	 20			; 00000014H
  00962	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  00968	50		 push	 eax
  00969	8d 8d d0 e7 ff
	ff		 lea	 ecx, DWORD PTR _cliper$[ebp]
  0096f	51		 push	 ecx
  00970	e8 00 00 00 00	 call	 _Byte2Hex
  00975	83 c4 10	 add	 esp, 16			; 00000010H

; 215  : 	printf("Sha1-abc:%s\r\n",hexer);

  00978	8b f4		 mov	 esi, esp
  0097a	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  00980	50		 push	 eax
  00981	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IFJLMJNL@Sha1?9abc?3?$CFs?$AN?6?$AA@
  00986	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  0098c	83 c4 08	 add	 esp, 8
  0098f	3b f4		 cmp	 esi, esp
  00991	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 216  : 	memset(cliper,0,CLIPERLEN);

  00996	68 00 04 00 00	 push	 1024			; 00000400H
  0099b	6a 00		 push	 0
  0099d	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  009a3	50		 push	 eax
  009a4	e8 00 00 00 00	 call	 _memset
  009a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 217  : 	memset(pliper,0,CLIPERLEN);

  009ac	68 00 04 00 00	 push	 1024			; 00000400H
  009b1	6a 00		 push	 0
  009b3	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  009b9	50		 push	 eax
  009ba	e8 00 00 00 00	 call	 _memset
  009bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 	memset(hexer,0,CLIPERLEN);

  009c2	68 00 04 00 00	 push	 1024			; 00000400H
  009c7	6a 00		 push	 0
  009c9	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  009cf	50		 push	 eax
  009d0	e8 00 00 00 00	 call	 _memset
  009d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 219  : 
; 220  : 	//CRC32-CRC64
; 221  : 	;
; 222  : 	Int2HexStr(GenCrc32((unsigned char*)verb,verb_len),hexer);

  009d8	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  009de	50		 push	 eax
  009df	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  009e5	51		 push	 ecx
  009e6	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  009ec	52		 push	 edx
  009ed	e8 00 00 00 00	 call	 _GenCrc32
  009f2	83 c4 08	 add	 esp, 8
  009f5	33 c9		 xor	 ecx, ecx
  009f7	51		 push	 ecx
  009f8	50		 push	 eax
  009f9	e8 00 00 00 00	 call	 _Int2HexStr
  009fe	83 c4 0c	 add	 esp, 12			; 0000000cH

; 223  : 	Int2HexStr(GenCrc64((unsigned char*)verb,verb_len),cliper);

  00a01	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00a07	50		 push	 eax
  00a08	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  00a0e	51		 push	 ecx
  00a0f	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  00a15	52		 push	 edx
  00a16	e8 00 00 00 00	 call	 _GenCrc64
  00a1b	83 c4 08	 add	 esp, 8
  00a1e	52		 push	 edx
  00a1f	50		 push	 eax
  00a20	e8 00 00 00 00	 call	 _Int2HexStr
  00a25	83 c4 0c	 add	 esp, 12			; 0000000cH

; 224  : 	printf("CRC32-abc:%s\r\n",hexer);

  00a28	8b f4		 mov	 esi, esp
  00a2a	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  00a30	50		 push	 eax
  00a31	68 00 00 00 00	 push	 OFFSET ??_C@_0P@NIGPBFEN@CRC32?9abc?3?$CFs?$AN?6?$AA@
  00a36	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00a3c	83 c4 08	 add	 esp, 8
  00a3f	3b f4		 cmp	 esi, esp
  00a41	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 225  : 	printf("CRC64-abc:%s\r\n",cliper);

  00a46	8b f4		 mov	 esi, esp
  00a48	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00a4e	50		 push	 eax
  00a4f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KIHJKIBO@CRC64?9abc?3?$CFs?$AN?6?$AA@
  00a54	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00a5a	83 c4 08	 add	 esp, 8
  00a5d	3b f4		 cmp	 esi, esp
  00a5f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 226  : 	memset(cliper,0,CLIPERLEN);

  00a64	68 00 04 00 00	 push	 1024			; 00000400H
  00a69	6a 00		 push	 0
  00a6b	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00a71	50		 push	 eax
  00a72	e8 00 00 00 00	 call	 _memset
  00a77	83 c4 0c	 add	 esp, 12			; 0000000cH

; 227  : 	memset(pliper,0,CLIPERLEN);

  00a7a	68 00 04 00 00	 push	 1024			; 00000400H
  00a7f	6a 00		 push	 0
  00a81	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00a87	50		 push	 eax
  00a88	e8 00 00 00 00	 call	 _memset
  00a8d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 228  : 	memset(hexer,0,CLIPERLEN);

  00a90	68 00 04 00 00	 push	 1024			; 00000400H
  00a95	6a 00		 push	 0
  00a97	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  00a9d	50		 push	 eax
  00a9e	e8 00 00 00 00	 call	 _memset
  00aa3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 229  : 
; 230  : 	///*
; 231  : 	//RC5
; 232  : 	rc_ctx.mode = RC_Mode_RC5;

  00aa6	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _rc_ctx$[ebp+32], 0

; 233  : 	RCInit(&rc_ctx);

  00ab0	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _rc_ctx$[ebp]
  00ab6	50		 push	 eax
  00ab7	e8 00 00 00 00	 call	 _RCInit
  00abc	83 c4 04	 add	 esp, 4

; 234  : 	RCEncrypt(&rc_ctx,verb,verb_len,cliper);

  00abf	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00ac5	50		 push	 eax
  00ac6	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  00acc	51		 push	 ecx
  00acd	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  00ad3	52		 push	 edx
  00ad4	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _rc_ctx$[ebp]
  00ada	50		 push	 eax
  00adb	e8 00 00 00 00	 call	 _RCEncrypt
  00ae0	83 c4 10	 add	 esp, 16			; 00000010H

; 235  : 	Byte2Hex((unsigned char*)cliper,hexer,verb_len,0);

  00ae3	6a 00		 push	 0
  00ae5	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00aeb	50		 push	 eax
  00aec	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  00af2	51		 push	 ecx
  00af3	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  00af9	52		 push	 edx
  00afa	e8 00 00 00 00	 call	 _Byte2Hex
  00aff	83 c4 10	 add	 esp, 16			; 00000010H

; 236  : 	RCDecrypt(&rc_ctx,cliper,cliper_len,pliper);

  00b02	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00b08	50		 push	 eax
  00b09	8b 8d 88 db ff
	ff		 mov	 ecx, DWORD PTR _cliper_len$[ebp]
  00b0f	51		 push	 ecx
  00b10	8d 95 d0 e7 ff
	ff		 lea	 edx, DWORD PTR _cliper$[ebp]
  00b16	52		 push	 edx
  00b17	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _rc_ctx$[ebp]
  00b1d	50		 push	 eax
  00b1e	e8 00 00 00 00	 call	 _RCDecrypt
  00b23	83 c4 10	 add	 esp, 16			; 00000010H

; 237  : 	printf("RC5:%s,%s\r\n",hexer,pliper);

  00b26	8b f4		 mov	 esi, esp
  00b28	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00b2e	50		 push	 eax
  00b2f	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  00b35	51		 push	 ecx
  00b36	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LAOBDGML@RC5?3?$CFs?0?$CFs?$AN?6?$AA@
  00b3b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00b41	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b44	3b f4		 cmp	 esi, esp
  00b46	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 238  : 	RCDestroy(&rc_ctx);

  00b4b	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _rc_ctx$[ebp]
  00b51	50		 push	 eax
  00b52	e8 00 00 00 00	 call	 _RCDestroy
  00b57	83 c4 04	 add	 esp, 4

; 239  : 	memset(cliper,0,CLIPERLEN);

  00b5a	68 00 04 00 00	 push	 1024			; 00000400H
  00b5f	6a 00		 push	 0
  00b61	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00b67	50		 push	 eax
  00b68	e8 00 00 00 00	 call	 _memset
  00b6d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 240  : 	memset(pliper,0,CLIPERLEN);

  00b70	68 00 04 00 00	 push	 1024			; 00000400H
  00b75	6a 00		 push	 0
  00b77	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00b7d	50		 push	 eax
  00b7e	e8 00 00 00 00	 call	 _memset
  00b83	83 c4 0c	 add	 esp, 12			; 0000000cH

; 241  : 	memset(hexer,0,CLIPERLEN);

  00b86	68 00 04 00 00	 push	 1024			; 00000400H
  00b8b	6a 00		 push	 0
  00b8d	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  00b93	50		 push	 eax
  00b94	e8 00 00 00 00	 call	 _memset
  00b99	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 	//*/
; 243  : 	//RC6
; 244  : 	rc_ctx.mode = RC_Mode_RC6;

  00b9c	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _rc_ctx$[ebp+32], 1

; 245  : 	RCInit(&rc_ctx);

  00ba6	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _rc_ctx$[ebp]
  00bac	50		 push	 eax
  00bad	e8 00 00 00 00	 call	 _RCInit
  00bb2	83 c4 04	 add	 esp, 4

; 246  : 	//verb_len = 3;
; 247  : 	RCEncrypt(&rc_ctx,verb,verb_len,cliper);

  00bb5	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00bbb	50		 push	 eax
  00bbc	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  00bc2	51		 push	 ecx
  00bc3	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  00bc9	52		 push	 edx
  00bca	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _rc_ctx$[ebp]
  00bd0	50		 push	 eax
  00bd1	e8 00 00 00 00	 call	 _RCEncrypt
  00bd6	83 c4 10	 add	 esp, 16			; 00000010H

; 248  : 	Byte2Hex((unsigned char*)cliper,hexer,ENRC6SIZE(verb_len),0);

  00bd9	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00bdf	83 e0 0f	 and	 eax, 15			; 0000000fH
  00be2	74 1c		 je	 SHORT $LN5@main
  00be4	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  00bea	83 c1 10	 add	 ecx, 16			; 00000010H
  00bed	8b 95 94 db ff
	ff		 mov	 edx, DWORD PTR _verb_len$[ebp]
  00bf3	83 e2 0f	 and	 edx, 15			; 0000000fH
  00bf6	2b ca		 sub	 ecx, edx
  00bf8	89 8d c0 da ff
	ff		 mov	 DWORD PTR tv445[ebp], ecx
  00bfe	eb 0c		 jmp	 SHORT $LN6@main
$LN5@main:
  00c00	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00c06	89 85 c0 da ff
	ff		 mov	 DWORD PTR tv445[ebp], eax
$LN6@main:
  00c0c	6a 00		 push	 0
  00c0e	8b 8d c0 da ff
	ff		 mov	 ecx, DWORD PTR tv445[ebp]
  00c14	51		 push	 ecx
  00c15	8d 95 c0 df ff
	ff		 lea	 edx, DWORD PTR _hexer$[ebp]
  00c1b	52		 push	 edx
  00c1c	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00c22	50		 push	 eax
  00c23	e8 00 00 00 00	 call	 _Byte2Hex
  00c28	83 c4 10	 add	 esp, 16			; 00000010H

; 249  : 	RCDecrypt(&rc_ctx,cliper,ENRC6SIZE(verb_len),pliper);

  00c2b	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00c31	83 e0 0f	 and	 eax, 15			; 0000000fH
  00c34	74 1c		 je	 SHORT $LN7@main
  00c36	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  00c3c	83 c1 10	 add	 ecx, 16			; 00000010H
  00c3f	8b 95 94 db ff
	ff		 mov	 edx, DWORD PTR _verb_len$[ebp]
  00c45	83 e2 0f	 and	 edx, 15			; 0000000fH
  00c48	2b ca		 sub	 ecx, edx
  00c4a	89 8d c0 da ff
	ff		 mov	 DWORD PTR tv454[ebp], ecx
  00c50	eb 0c		 jmp	 SHORT $LN8@main
$LN7@main:
  00c52	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00c58	89 85 c0 da ff
	ff		 mov	 DWORD PTR tv454[ebp], eax
$LN8@main:
  00c5e	8d 8d c8 e3 ff
	ff		 lea	 ecx, DWORD PTR _pliper$[ebp]
  00c64	51		 push	 ecx
  00c65	8b 95 c0 da ff
	ff		 mov	 edx, DWORD PTR tv454[ebp]
  00c6b	52		 push	 edx
  00c6c	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00c72	50		 push	 eax
  00c73	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _rc_ctx$[ebp]
  00c79	51		 push	 ecx
  00c7a	e8 00 00 00 00	 call	 _RCDecrypt
  00c7f	83 c4 10	 add	 esp, 16			; 00000010H

; 250  : 	printf("RC6:%s,%s\r\n",hexer,pliper);

  00c82	8b f4		 mov	 esi, esp
  00c84	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00c8a	50		 push	 eax
  00c8b	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  00c91	51		 push	 ecx
  00c92	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FLNGINMI@RC6?3?$CFs?0?$CFs?$AN?6?$AA@
  00c97	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00c9d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ca0	3b f4		 cmp	 esi, esp
  00ca2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 251  : 	RCDestroy(&rc_ctx);

  00ca7	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _rc_ctx$[ebp]
  00cad	50		 push	 eax
  00cae	e8 00 00 00 00	 call	 _RCDestroy
  00cb3	83 c4 04	 add	 esp, 4

; 252  : 	memset(cliper,0,CLIPERLEN);

  00cb6	68 00 04 00 00	 push	 1024			; 00000400H
  00cbb	6a 00		 push	 0
  00cbd	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00cc3	50		 push	 eax
  00cc4	e8 00 00 00 00	 call	 _memset
  00cc9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 253  : 	memset(pliper,0,CLIPERLEN);

  00ccc	68 00 04 00 00	 push	 1024			; 00000400H
  00cd1	6a 00		 push	 0
  00cd3	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00cd9	50		 push	 eax
  00cda	e8 00 00 00 00	 call	 _memset
  00cdf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 254  : 	memset(hexer,0,CLIPERLEN);

  00ce2	68 00 04 00 00	 push	 1024			; 00000400H
  00ce7	6a 00		 push	 0
  00ce9	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  00cef	50		 push	 eax
  00cf0	e8 00 00 00 00	 call	 _memset
  00cf5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 255  : 
; 256  : 	//rijndael
; 257  : 	RijndaelInit(&rd_ctx);

  00cf8	8d 85 f4 fc ff
	ff		 lea	 eax, DWORD PTR _rd_ctx$[ebp]
  00cfe	50		 push	 eax
  00cff	e8 00 00 00 00	 call	 _RijndaelInit
  00d04	83 c4 04	 add	 esp, 4

; 258  : 	RijndaelEncrypt(&rd_ctx,verb,verb_len,cliper);

  00d07	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00d0d	50		 push	 eax
  00d0e	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  00d14	51		 push	 ecx
  00d15	8b 95 a0 db ff
	ff		 mov	 edx, DWORD PTR _verb$[ebp]
  00d1b	52		 push	 edx
  00d1c	8d 85 f4 fc ff
	ff		 lea	 eax, DWORD PTR _rd_ctx$[ebp]
  00d22	50		 push	 eax
  00d23	e8 00 00 00 00	 call	 _RijndaelEncrypt
  00d28	83 c4 10	 add	 esp, 16			; 00000010H

; 259  : 	Byte2Hex((unsigned char*)cliper,hexer,ENRIJNDAELSIZE(verb_len),0);

  00d2b	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00d31	83 e0 0f	 and	 eax, 15			; 0000000fH
  00d34	74 1c		 je	 SHORT $LN9@main
  00d36	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  00d3c	83 c1 10	 add	 ecx, 16			; 00000010H
  00d3f	8b 95 94 db ff
	ff		 mov	 edx, DWORD PTR _verb_len$[ebp]
  00d45	83 e2 0f	 and	 edx, 15			; 0000000fH
  00d48	2b ca		 sub	 ecx, edx
  00d4a	89 8d c0 da ff
	ff		 mov	 DWORD PTR tv483[ebp], ecx
  00d50	eb 0c		 jmp	 SHORT $LN10@main
$LN9@main:
  00d52	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00d58	89 85 c0 da ff
	ff		 mov	 DWORD PTR tv483[ebp], eax
$LN10@main:
  00d5e	6a 00		 push	 0
  00d60	8b 8d c0 da ff
	ff		 mov	 ecx, DWORD PTR tv483[ebp]
  00d66	51		 push	 ecx
  00d67	8d 95 c0 df ff
	ff		 lea	 edx, DWORD PTR _hexer$[ebp]
  00d6d	52		 push	 edx
  00d6e	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00d74	50		 push	 eax
  00d75	e8 00 00 00 00	 call	 _Byte2Hex
  00d7a	83 c4 10	 add	 esp, 16			; 00000010H

; 260  : 	RijndaelDecrypt(&rd_ctx,cliper,ENRIJNDAELSIZE(verb_len),pliper);

  00d7d	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00d83	83 e0 0f	 and	 eax, 15			; 0000000fH
  00d86	74 1c		 je	 SHORT $LN11@main
  00d88	8b 8d 94 db ff
	ff		 mov	 ecx, DWORD PTR _verb_len$[ebp]
  00d8e	83 c1 10	 add	 ecx, 16			; 00000010H
  00d91	8b 95 94 db ff
	ff		 mov	 edx, DWORD PTR _verb_len$[ebp]
  00d97	83 e2 0f	 and	 edx, 15			; 0000000fH
  00d9a	2b ca		 sub	 ecx, edx
  00d9c	89 8d c0 da ff
	ff		 mov	 DWORD PTR tv492[ebp], ecx
  00da2	eb 0c		 jmp	 SHORT $LN12@main
$LN11@main:
  00da4	8b 85 94 db ff
	ff		 mov	 eax, DWORD PTR _verb_len$[ebp]
  00daa	89 85 c0 da ff
	ff		 mov	 DWORD PTR tv492[ebp], eax
$LN12@main:
  00db0	8d 8d c8 e3 ff
	ff		 lea	 ecx, DWORD PTR _pliper$[ebp]
  00db6	51		 push	 ecx
  00db7	8b 95 c0 da ff
	ff		 mov	 edx, DWORD PTR tv492[ebp]
  00dbd	52		 push	 edx
  00dbe	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00dc4	50		 push	 eax
  00dc5	8d 8d f4 fc ff
	ff		 lea	 ecx, DWORD PTR _rd_ctx$[ebp]
  00dcb	51		 push	 ecx
  00dcc	e8 00 00 00 00	 call	 _RijndaelDecrypt
  00dd1	83 c4 10	 add	 esp, 16			; 00000010H

; 261  : 	printf("RIJNDAEL:%s,%s\r\n",hexer,pliper);

  00dd4	8b f4		 mov	 esi, esp
  00dd6	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00ddc	50		 push	 eax
  00ddd	8d 8d c0 df ff
	ff		 lea	 ecx, DWORD PTR _hexer$[ebp]
  00de3	51		 push	 ecx
  00de4	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KMHIJBEJ@RIJNDAEL?3?$CFs?0?$CFs?$AN?6?$AA@
  00de9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00def	83 c4 0c	 add	 esp, 12			; 0000000cH
  00df2	3b f4		 cmp	 esi, esp
  00df4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 262  : 	memset(cliper,0,CLIPERLEN);

  00df9	68 00 04 00 00	 push	 1024			; 00000400H
  00dfe	6a 00		 push	 0
  00e00	8d 85 d0 e7 ff
	ff		 lea	 eax, DWORD PTR _cliper$[ebp]
  00e06	50		 push	 eax
  00e07	e8 00 00 00 00	 call	 _memset
  00e0c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 263  : 	memset(pliper,0,CLIPERLEN);

  00e0f	68 00 04 00 00	 push	 1024			; 00000400H
  00e14	6a 00		 push	 0
  00e16	8d 85 c8 e3 ff
	ff		 lea	 eax, DWORD PTR _pliper$[ebp]
  00e1c	50		 push	 eax
  00e1d	e8 00 00 00 00	 call	 _memset
  00e22	83 c4 0c	 add	 esp, 12			; 0000000cH

; 264  : 	memset(hexer,0,CLIPERLEN);

  00e25	68 00 04 00 00	 push	 1024			; 00000400H
  00e2a	6a 00		 push	 0
  00e2c	8d 85 c0 df ff
	ff		 lea	 eax, DWORD PTR _hexer$[ebp]
  00e32	50		 push	 eax
  00e33	e8 00 00 00 00	 call	 _memset
  00e38	83 c4 0c	 add	 esp, 12			; 0000000cH

; 265  : 	//RC6SetKey(&rc6_ctx,verb,verb_len);
; 266  : 	/*
; 267  : 	RsaInit("d:\\rsa.txt",&rsa_ctx,F_ALL,RSA_DEC);//F_ALL);
; 268  : 	if (RSA_ERR_NOERR != RsaCheckContext(&rsa_ctx,F_ALL))//;//检测
; 269  : 	{
; 270  : 		return;
; 271  : 	}
; 272  : 	//-----------------------------------------
; 273  : 	publicKey.pBase = (char*)malloc(1024);
; 274  : 	publicKey.pMod = (char*)malloc(1024);
; 275  : 	privateKey.pBase = (char*)malloc(1024);
; 276  : 	privateKey.pMod = (char*)malloc(1024);
; 277  : 
; 278  : 	RsaGenPrivateKey(&rsa_ctx,&privateKey);
; 279  : 	RsaGenPublicKey(&rsa_ctx,&publicKey);
; 280  : 	RsaReadPrivateKey(&rsa_ctx,&privateKey);
; 281  : 	RsaReadPublicKey(&rsa_ctx,&publicKey);
; 282  : 	free(publicKey.pBase);
; 283  : 	free(publicKey.pMod);
; 284  : 	free(privateKey.pBase);
; 285  : 	free(privateKey.pMod);
; 286  : 	//-----------------------------------------
; 287  : 	e = RsaEncrypt(&rsa_ctx,verb,verb_len,cliper);//900
; 288  : 	CYByte2Hex((unsigned char*)cliper,hexer,e,0);
; 289  : 	d = RsaDecrypt(&rsa_ctx,cliper,e,pliper);
; 290  : 	printf("RSA:%s,%s\r\n",hexer,pliper);
; 291  : 	memset(cliper,0,CLIPERLEN);
; 292  : 	memset(pliper,0,CLIPERLEN);
; 293  : 	memset(hexer,0,CLIPERLEN);
; 294  : 	*/
; 295  : 	//PrintContext(&rsa_ctx);
; 296  : 	//RsaInit(NULL,&rsa_ctx,F_P|F_Q,RSA_HEX);
; 297  : 	//CaclePrimesToFile(1024,10000,"d:\\primes_16_2.txt");
; 298  : 	//GetED(&rsaElement);
; 299  : 	//printf("e=%u,d=%u\r\n",rsaElement.e,rsaElement.d);
; 300  : 	//printf("cp=%u,cc=%u\r\n",e,d);
; 301  : 	//printf("%x,%x,%x,%x\r\n",(unsigned int)(-60),-60,((unsigned int)(-60))>>13,(-60)>>13);
; 302  : 	//printf("%x",*((int*)cArr));
; 303  : 	getchar();

  00e3b	8b f4		 mov	 esi, esp
  00e3d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getchar
  00e43	3b f4		 cmp	 esi, esp
  00e45	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 304  : }

  00e4a	33 c0		 xor	 eax, eax
  00e4c	52		 push	 edx
  00e4d	8b cd		 mov	 ecx, ebp
  00e4f	50		 push	 eax
  00e50	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN26@main
  00e56	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00e5b	58		 pop	 eax
  00e5c	5a		 pop	 edx
  00e5d	5f		 pop	 edi
  00e5e	5e		 pop	 esi
  00e5f	5b		 pop	 ebx
  00e60	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e63	33 cd		 xor	 ecx, ebp
  00e65	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e6a	81 c4 40 25 00
	00		 add	 esp, 9536		; 00002540H
  00e70	3b ec		 cmp	 ebp, esp
  00e72	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00e77	8b e5		 mov	 esp, ebp
  00e79	5d		 pop	 ebp
  00e7a	c3		 ret	 0
  00e7b	90		 npad	 1
$LN26@main:
  00e7c	0c 00 00 00	 DD	 12			; 0000000cH
  00e80	00 00 00 00	 DD	 $LN25@main
$LN25@main:
  00e84	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00e88	58 00 00 00	 DD	 88			; 00000058H
  00e8c	00 00 00 00	 DD	 $LN13@main
  00e90	3c ff ff ff	 DD	 -196			; ffffff3cH
  00e94	5c 00 00 00	 DD	 92			; 0000005cH
  00e98	00 00 00 00	 DD	 $LN14@main
  00e9c	10 ff ff ff	 DD	 -240			; ffffff10H
  00ea0	24 00 00 00	 DD	 36			; 00000024H
  00ea4	00 00 00 00	 DD	 $LN15@main
  00ea8	f4 fc ff ff	 DD	 -780			; fffffcf4H
  00eac	14 02 00 00	 DD	 532			; 00000214H
  00eb0	00 00 00 00	 DD	 $LN16@main
  00eb4	98 ec ff ff	 DD	 -4968			; ffffec98H
  00eb8	54 10 00 00	 DD	 4180			; 00001054H
  00ebc	00 00 00 00	 DD	 $LN17@main
  00ec0	00 ec ff ff	 DD	 -5120			; ffffec00H
  00ec4	90 00 00 00	 DD	 144			; 00000090H
  00ec8	00 00 00 00	 DD	 $LN18@main
  00ecc	e4 eb ff ff	 DD	 -5148			; ffffebe4H
  00ed0	14 00 00 00	 DD	 20			; 00000014H
  00ed4	00 00 00 00	 DD	 $LN19@main
  00ed8	d0 e7 ff ff	 DD	 -6192			; ffffe7d0H
  00edc	00 04 00 00	 DD	 1024			; 00000400H
  00ee0	00 00 00 00	 DD	 $LN20@main
  00ee4	c8 e3 ff ff	 DD	 -7224			; ffffe3c8H
  00ee8	00 04 00 00	 DD	 1024			; 00000400H
  00eec	00 00 00 00	 DD	 $LN21@main
  00ef0	c0 df ff ff	 DD	 -8256			; ffffdfc0H
  00ef4	00 04 00 00	 DD	 1024			; 00000400H
  00ef8	00 00 00 00	 DD	 $LN22@main
  00efc	b4 df ff ff	 DD	 -8268			; ffffdfb4H
  00f00	04 00 00 00	 DD	 4
  00f04	00 00 00 00	 DD	 $LN23@main
  00f08	ac db ff ff	 DD	 -9300			; ffffdbacH
  00f0c	00 04 00 00	 DD	 1024			; 00000400H
  00f10	00 00 00 00	 DD	 $LN24@main
$LN24@main:
  00f14	62		 DB	 98			; 00000062H
  00f15	61		 DB	 97			; 00000061H
  00f16	73		 DB	 115			; 00000073H
  00f17	65		 DB	 101			; 00000065H
  00f18	36		 DB	 54			; 00000036H
  00f19	34		 DB	 52			; 00000034H
  00f1a	00		 DB	 0
$LN23@main:
  00f1b	63		 DB	 99			; 00000063H
  00f1c	41		 DB	 65			; 00000041H
  00f1d	72		 DB	 114			; 00000072H
  00f1e	72		 DB	 114			; 00000072H
  00f1f	00		 DB	 0
$LN22@main:
  00f20	68		 DB	 104			; 00000068H
  00f21	65		 DB	 101			; 00000065H
  00f22	78		 DB	 120			; 00000078H
  00f23	65		 DB	 101			; 00000065H
  00f24	72		 DB	 114			; 00000072H
  00f25	00		 DB	 0
$LN21@main:
  00f26	70		 DB	 112			; 00000070H
  00f27	6c		 DB	 108			; 0000006cH
  00f28	69		 DB	 105			; 00000069H
  00f29	70		 DB	 112			; 00000070H
  00f2a	65		 DB	 101			; 00000065H
  00f2b	72		 DB	 114			; 00000072H
  00f2c	00		 DB	 0
$LN20@main:
  00f2d	63		 DB	 99			; 00000063H
  00f2e	6c		 DB	 108			; 0000006cH
  00f2f	69		 DB	 105			; 00000069H
  00f30	70		 DB	 112			; 00000070H
  00f31	65		 DB	 101			; 00000065H
  00f32	72		 DB	 114			; 00000072H
  00f33	00		 DB	 0
$LN19@main:
  00f34	74		 DB	 116			; 00000074H
  00f35	65		 DB	 101			; 00000065H
  00f36	61		 DB	 97			; 00000061H
  00f37	5f		 DB	 95			; 0000005fH
  00f38	63		 DB	 99			; 00000063H
  00f39	74		 DB	 116			; 00000074H
  00f3a	78		 DB	 120			; 00000078H
  00f3b	00		 DB	 0
$LN18@main:
  00f3c	64		 DB	 100			; 00000064H
  00f3d	65		 DB	 101			; 00000065H
  00f3e	73		 DB	 115			; 00000073H
  00f3f	5f		 DB	 95			; 0000005fH
  00f40	63		 DB	 99			; 00000063H
  00f41	74		 DB	 116			; 00000074H
  00f42	78		 DB	 120			; 00000078H
  00f43	00		 DB	 0
$LN17@main:
  00f44	62		 DB	 98			; 00000062H
  00f45	66		 DB	 102			; 00000066H
  00f46	5f		 DB	 95			; 0000005fH
  00f47	63		 DB	 99			; 00000063H
  00f48	74		 DB	 116			; 00000074H
  00f49	78		 DB	 120			; 00000078H
  00f4a	00		 DB	 0
$LN16@main:
  00f4b	72		 DB	 114			; 00000072H
  00f4c	64		 DB	 100			; 00000064H
  00f4d	5f		 DB	 95			; 0000005fH
  00f4e	63		 DB	 99			; 00000063H
  00f4f	74		 DB	 116			; 00000074H
  00f50	78		 DB	 120			; 00000078H
  00f51	00		 DB	 0
$LN15@main:
  00f52	72		 DB	 114			; 00000072H
  00f53	63		 DB	 99			; 00000063H
  00f54	5f		 DB	 95			; 0000005fH
  00f55	63		 DB	 99			; 00000063H
  00f56	74		 DB	 116			; 00000074H
  00f57	78		 DB	 120			; 00000078H
  00f58	00		 DB	 0
$LN14@main:
  00f59	73		 DB	 115			; 00000073H
  00f5a	68		 DB	 104			; 00000068H
  00f5b	61		 DB	 97			; 00000061H
  00f5c	5f		 DB	 95			; 0000005fH
  00f5d	63		 DB	 99			; 00000063H
  00f5e	74		 DB	 116			; 00000074H
  00f5f	78		 DB	 120			; 00000078H
  00f60	00		 DB	 0
$LN13@main:
  00f61	6d		 DB	 109			; 0000006dH
  00f62	64		 DB	 100			; 00000064H
  00f63	35		 DB	 53			; 00000035H
  00f64	5f		 DB	 95			; 0000005fH
  00f65	63		 DB	 99			; 00000063H
  00f66	74		 DB	 116			; 00000074H
  00f67	78		 DB	 120			; 00000078H
  00f68	00		 DB	 0
_main	ENDP
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\windows\belial\crypt\Base64.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_pem_array DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02bH
	DB	02fH
_re_pem_array DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03eH
	DB	00H
	DB	00H
	DB	00H
	DB	03fH
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_url_array DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02aH
	DB	05fH
_re_url_array DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03eH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03fH
	DB	00H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_regular_array DB 041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	047H
	DB	048H
	DB	049H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	04dH
	DB	04eH
	DB	04fH
	DB	050H
	DB	051H
	DB	052H
	DB	053H
	DB	054H
	DB	055H
	DB	056H
	DB	057H
	DB	058H
	DB	059H
	DB	05aH
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	021H
	DB	02dH
_re_regular_array DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03eH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	03fH
	DB	00H
	DB	00H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
PUBLIC	_Base64Encrypt
EXTRN	__RTC_CheckEsp:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\windows\belial\crypt\base64.c
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _Base64Encrypt
_TEXT	SEGMENT
_pDict$ = -80						; size = 4
_k$ = -68						; size = 4
_j$ = -56						; size = 4
_i$ = -44						; size = 4
_byte2$ = -29						; size = 1
_byte1$ = -17						; size = 1
_byte0$ = -5						; size = 1
_pInput$ = 8						; size = 4
_nSize$ = 12						; size = 4
_pOutput$ = 16						; size = 4
_mode$ = 20						; size = 4
_Base64Encrypt PROC					; COMDAT

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 153  : 	unsigned char byte0;
; 154  : 	unsigned char byte1;
; 155  : 	unsigned char byte2;
; 156  : 	unsigned int i,j,k = 0;

  0001e	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 157  : 	unsigned char* pDict = NULL;//ictionaries

  00025	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], 0

; 158  : 
; 159  : 	SelectDict(&pDict,mode);

  0002c	8b 45 14	 mov	 eax, DWORD PTR _mode$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d b0	 lea	 ecx, DWORD PTR _pDict$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _SelectDict
  00039	83 c4 08	 add	 esp, 8

; 160  : 
; 161  : 	for (i=0; i<nSize; i+=3)//每次处理三个字节

  0003c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00043	eb 09		 jmp	 SHORT $LN8@Base64Encr
$LN7@Base64Encr:
  00045	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00048	83 c0 03	 add	 eax, 3
  0004b	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN8@Base64Encr:
  0004e	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00051	3b 45 0c	 cmp	 eax, DWORD PTR _nSize$[ebp]
  00054	0f 83 02 02 00
	00		 jae	 $LN6@Base64Encr

; 162  : 	{
; 163  : 		j = 0;//需要补充的字节数

  0005a	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 164  : 		if ((i + 3) > nSize)

  00061	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00064	83 c0 03	 add	 eax, 3
  00067	3b 45 0c	 cmp	 eax, DWORD PTR _nSize$[ebp]
  0006a	76 0c		 jbe	 SHORT $LN5@Base64Encr

; 165  : 		{
; 166  : 			j = i + 3 - nSize;

  0006c	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0006f	83 c0 03	 add	 eax, 3
  00072	2b 45 0c	 sub	 eax, DWORD PTR _nSize$[ebp]
  00075	89 45 c8	 mov	 DWORD PTR _j$[ebp], eax
$LN5@Base64Encr:

; 167  : 		}
; 168  : 		//1个字节被转化为
; 169  : 		//如:11001101
; 170  : 		//11001101 00000000 00000000 (补0)
; 171  : 		//00110011 00010000 00000000 00000000 (转为4个字节)
; 172  : 		if (j == 1)

  00078	83 7d c8 01	 cmp	 DWORD PTR _j$[ebp], 1
  0007c	75 76		 jne	 SHORT $LN4@Base64Encr

; 173  : 		{
; 174  : 			byte0 = *(pInput + i);

  0007e	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  00081	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  00084	8a 08		 mov	 cl, BYTE PTR [eax]
  00086	88 4d fb	 mov	 BYTE PTR _byte0$[ebp], cl

; 175  : 			//第一个前面6位                              00111111
; 176  : 			*(pOutput + k++) = *(pDict + ((byte0 >> 2) & 0x3f));

  00089	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte0$[ebp]
  0008d	c1 f8 02	 sar	 eax, 2
  00090	83 e0 3f	 and	 eax, 63			; 0000003fH
  00093	8b 4d 10	 mov	 ecx, DWORD PTR _pOutput$[ebp]
  00096	03 4d bc	 add	 ecx, DWORD PTR _k$[ebp]
  00099	8b 55 b0	 mov	 edx, DWORD PTR _pDict$[ebp]
  0009c	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0009f	88 01		 mov	 BYTE PTR [ecx], al
  000a1	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  000a4	83 c1 01	 add	 ecx, 1
  000a7	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx

; 177  : 			//第一个字节后面2位                          00110000
; 178  : 			*(pOutput + k++) = *(pDict + ((byte0 << 4) & 0x30));

  000aa	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte0$[ebp]
  000ae	c1 e0 04	 shl	 eax, 4
  000b1	83 e0 30	 and	 eax, 48			; 00000030H
  000b4	8b 4d 10	 mov	 ecx, DWORD PTR _pOutput$[ebp]
  000b7	03 4d bc	 add	 ecx, DWORD PTR _k$[ebp]
  000ba	8b 55 b0	 mov	 edx, DWORD PTR _pDict$[ebp]
  000bd	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  000c0	88 01		 mov	 BYTE PTR [ecx], al
  000c2	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  000c5	83 c1 01	 add	 ecx, 1
  000c8	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx

; 179  : 			 //加上=
; 180  : 			*(pOutput + k++) = ZEROCHAR;

  000cb	8b 45 10	 mov	 eax, DWORD PTR _pOutput$[ebp]
  000ce	03 45 bc	 add	 eax, DWORD PTR _k$[ebp]
  000d1	c6 00 3d	 mov	 BYTE PTR [eax], 61	; 0000003dH
  000d4	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  000d7	83 c1 01	 add	 ecx, 1
  000da	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx

; 181  : 			 //加上=
; 182  : 			*(pOutput + k++) = ZEROCHAR;

  000dd	8b 45 10	 mov	 eax, DWORD PTR _pOutput$[ebp]
  000e0	03 45 bc	 add	 eax, DWORD PTR _k$[ebp]
  000e3	c6 00 3d	 mov	 BYTE PTR [eax], 61	; 0000003dH
  000e6	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  000e9	83 c1 01	 add	 ecx, 1
  000ec	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx
  000ef	e9 63 01 00 00	 jmp	 $LN3@Base64Encr
$LN4@Base64Encr:

; 183  : 		}
; 184  : 		else if (j == 2)

  000f4	83 7d c8 02	 cmp	 DWORD PTR _j$[ebp], 2
  000f8	0f 85 9d 00 00
	00		 jne	 $LN2@Base64Encr

; 185  : 		{
; 186  : 			byte0 = *(pInput + i);

  000fe	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  00101	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  00104	8a 08		 mov	 cl, BYTE PTR [eax]
  00106	88 4d fb	 mov	 BYTE PTR _byte0$[ebp], cl

; 187  : 			byte1 = *(pInput + i + 1);

  00109	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  0010c	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  0010f	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00112	88 4d ef	 mov	 BYTE PTR _byte1$[ebp], cl

; 188  : 			//第一个前面6位                              00111111
; 189  : 			*(pOutput + k++) = *(pDict + ((byte0 >> 2) & 0x3f));

  00115	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte0$[ebp]
  00119	c1 f8 02	 sar	 eax, 2
  0011c	83 e0 3f	 and	 eax, 63			; 0000003fH
  0011f	8b 4d 10	 mov	 ecx, DWORD PTR _pOutput$[ebp]
  00122	03 4d bc	 add	 ecx, DWORD PTR _k$[ebp]
  00125	8b 55 b0	 mov	 edx, DWORD PTR _pDict$[ebp]
  00128	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0012b	88 01		 mov	 BYTE PTR [ecx], al
  0012d	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  00130	83 c1 01	 add	 ecx, 1
  00133	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx

; 190  : 			//第一个字节后面2位 + 后一个字节的前面4位     00110000                 00001111
; 191  : 			*(pOutput + k++) = *(pDict + (((byte0 << 4) & 0x30) | (((byte1 >> 4) & 0xf))));

  00136	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte0$[ebp]
  0013a	c1 e0 04	 shl	 eax, 4
  0013d	83 e0 30	 and	 eax, 48			; 00000030H
  00140	0f b6 4d ef	 movzx	 ecx, BYTE PTR _byte1$[ebp]
  00144	c1 f9 04	 sar	 ecx, 4
  00147	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0014a	0b c1		 or	 eax, ecx
  0014c	8b 55 10	 mov	 edx, DWORD PTR _pOutput$[ebp]
  0014f	03 55 bc	 add	 edx, DWORD PTR _k$[ebp]
  00152	8b 4d b0	 mov	 ecx, DWORD PTR _pDict$[ebp]
  00155	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  00158	88 02		 mov	 BYTE PTR [edx], al
  0015a	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  0015d	83 c1 01	 add	 ecx, 1
  00160	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx

; 192  : 			//第二个字节的后面4位                        00111100
; 193  : 			*(pOutput + k++) = *(pDict + ((byte1 << 2) & 0x3C));

  00163	0f b6 45 ef	 movzx	 eax, BYTE PTR _byte1$[ebp]
  00167	c1 e0 02	 shl	 eax, 2
  0016a	83 e0 3c	 and	 eax, 60			; 0000003cH
  0016d	8b 4d 10	 mov	 ecx, DWORD PTR _pOutput$[ebp]
  00170	03 4d bc	 add	 ecx, DWORD PTR _k$[ebp]
  00173	8b 55 b0	 mov	 edx, DWORD PTR _pDict$[ebp]
  00176	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00179	88 01		 mov	 BYTE PTR [ecx], al
  0017b	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  0017e	83 c1 01	 add	 ecx, 1
  00181	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx

; 194  : 			 //加上=
; 195  : 			*(pOutput + k++) = ZEROCHAR;

  00184	8b 45 10	 mov	 eax, DWORD PTR _pOutput$[ebp]
  00187	03 45 bc	 add	 eax, DWORD PTR _k$[ebp]
  0018a	c6 00 3d	 mov	 BYTE PTR [eax], 61	; 0000003dH
  0018d	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  00190	83 c1 01	 add	 ecx, 1
  00193	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx

; 196  : 		}
; 197  : 		else

  00196	e9 bc 00 00 00	 jmp	 $LN3@Base64Encr
$LN2@Base64Encr:

; 198  : 		{
; 199  : 			byte0 = *(pInput + i);

  0019b	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  0019e	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  001a1	8a 08		 mov	 cl, BYTE PTR [eax]
  001a3	88 4d fb	 mov	 BYTE PTR _byte0$[ebp], cl

; 200  : 			byte1 = *(pInput + i + 1);

  001a6	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  001a9	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  001ac	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  001af	88 4d ef	 mov	 BYTE PTR _byte1$[ebp], cl

; 201  : 			byte2 = *(pInput + i + 2);

  001b2	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  001b5	03 45 d4	 add	 eax, DWORD PTR _i$[ebp]
  001b8	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  001bb	88 4d e3	 mov	 BYTE PTR _byte2$[ebp], cl

; 202  : 
; 203  : 			//第一个前面6位                              00111111
; 204  : 			*(pOutput + k++) = *(pDict + ((byte0 >> 2) & 0x3f));

  001be	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte0$[ebp]
  001c2	c1 f8 02	 sar	 eax, 2
  001c5	83 e0 3f	 and	 eax, 63			; 0000003fH
  001c8	8b 4d 10	 mov	 ecx, DWORD PTR _pOutput$[ebp]
  001cb	03 4d bc	 add	 ecx, DWORD PTR _k$[ebp]
  001ce	8b 55 b0	 mov	 edx, DWORD PTR _pDict$[ebp]
  001d1	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  001d4	88 01		 mov	 BYTE PTR [ecx], al
  001d6	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  001d9	83 c1 01	 add	 ecx, 1
  001dc	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx

; 205  : 
; 206  : 			//第一个字节后面2位 + 后一个字节的前面4位     00110000                 00001111
; 207  : 			*(pOutput + k++) = *(pDict + (((byte0 << 4) & 0x30) | (((byte1 >> 4) & 0xf))));

  001df	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte0$[ebp]
  001e3	c1 e0 04	 shl	 eax, 4
  001e6	83 e0 30	 and	 eax, 48			; 00000030H
  001e9	0f b6 4d ef	 movzx	 ecx, BYTE PTR _byte1$[ebp]
  001ed	c1 f9 04	 sar	 ecx, 4
  001f0	83 e1 0f	 and	 ecx, 15			; 0000000fH
  001f3	0b c1		 or	 eax, ecx
  001f5	8b 55 10	 mov	 edx, DWORD PTR _pOutput$[ebp]
  001f8	03 55 bc	 add	 edx, DWORD PTR _k$[ebp]
  001fb	8b 4d b0	 mov	 ecx, DWORD PTR _pDict$[ebp]
  001fe	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  00201	88 02		 mov	 BYTE PTR [edx], al
  00203	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  00206	83 c1 01	 add	 ecx, 1
  00209	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx

; 208  : 
; 209  : 			//第二个字节的后面4位+第三个字节的前面2位     00111100                00000011
; 210  : 			*(pOutput + k++) = *(pDict + (((byte1 << 2) & 0x3C) | ((byte2 >> 6) & 0x3)));

  0020c	0f b6 45 ef	 movzx	 eax, BYTE PTR _byte1$[ebp]
  00210	c1 e0 02	 shl	 eax, 2
  00213	83 e0 3c	 and	 eax, 60			; 0000003cH
  00216	0f b6 4d e3	 movzx	 ecx, BYTE PTR _byte2$[ebp]
  0021a	c1 f9 06	 sar	 ecx, 6
  0021d	83 e1 03	 and	 ecx, 3
  00220	0b c1		 or	 eax, ecx
  00222	8b 55 10	 mov	 edx, DWORD PTR _pOutput$[ebp]
  00225	03 55 bc	 add	 edx, DWORD PTR _k$[ebp]
  00228	8b 4d b0	 mov	 ecx, DWORD PTR _pDict$[ebp]
  0022b	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  0022e	88 02		 mov	 BYTE PTR [edx], al
  00230	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  00233	83 c1 01	 add	 ecx, 1
  00236	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx

; 211  : 
; 212  : 			//第三个字节的后面6位
; 213  : 			*(pOutput + k++) = *(pDict + (byte2 & 0x3f));

  00239	0f b6 45 e3	 movzx	 eax, BYTE PTR _byte2$[ebp]
  0023d	83 e0 3f	 and	 eax, 63			; 0000003fH
  00240	8b 4d 10	 mov	 ecx, DWORD PTR _pOutput$[ebp]
  00243	03 4d bc	 add	 ecx, DWORD PTR _k$[ebp]
  00246	8b 55 b0	 mov	 edx, DWORD PTR _pDict$[ebp]
  00249	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  0024c	88 01		 mov	 BYTE PTR [ecx], al
  0024e	8b 4d bc	 mov	 ecx, DWORD PTR _k$[ebp]
  00251	83 c1 01	 add	 ecx, 1
  00254	89 4d bc	 mov	 DWORD PTR _k$[ebp], ecx
$LN3@Base64Encr:

; 214  : 		}
; 215  : 	}

  00257	e9 e9 fd ff ff	 jmp	 $LN7@Base64Encr
$LN6@Base64Encr:

; 216  : 	return k;

  0025c	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]

; 217  : }

  0025f	52		 push	 edx
  00260	8b cd		 mov	 ecx, ebp
  00262	50		 push	 eax
  00263	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@Base64Encr
  00269	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0026e	58		 pop	 eax
  0026f	5a		 pop	 edx
  00270	5f		 pop	 edi
  00271	5e		 pop	 esi
  00272	5b		 pop	 ebx
  00273	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  00279	3b ec		 cmp	 ebp, esp
  0027b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00280	8b e5		 mov	 esp, ebp
  00282	5d		 pop	 ebp
  00283	c3		 ret	 0
$LN13@Base64Encr:
  00284	01 00 00 00	 DD	 1
  00288	00 00 00 00	 DD	 $LN12@Base64Encr
$LN12@Base64Encr:
  0028c	b0 ff ff ff	 DD	 -80			; ffffffb0H
  00290	04 00 00 00	 DD	 4
  00294	00 00 00 00	 DD	 $LN11@Base64Encr
$LN11@Base64Encr:
  00298	70		 DB	 112			; 00000070H
  00299	44		 DB	 68			; 00000044H
  0029a	69		 DB	 105			; 00000069H
  0029b	63		 DB	 99			; 00000063H
  0029c	74		 DB	 116			; 00000074H
  0029d	00		 DB	 0
_Base64Encrypt ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _SelectDict
_TEXT	SEGMENT
_pDict$ = -8						; size = 4
_pOutput$ = 8						; size = 4
_mode$ = 12						; size = 4
_SelectDict PROC					; COMDAT

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 100  : 	unsigned char* pDict = NULL;//ictionaries

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], 0

; 101  : 	/**确定字典*/
; 102  : 	if (mode == Base64_Mode_REG)

  00025	83 7d 0c 02	 cmp	 DWORD PTR _mode$[ebp], 2
  00029	75 09		 jne	 SHORT $LN6@SelectDict

; 103  : 	{
; 104  : 		pDict = regular_array;

  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], OFFSET _regular_array
  00032	eb 25		 jmp	 SHORT $LN5@SelectDict
$LN6@SelectDict:

; 105  : 	}
; 106  : 	else if (mode == Base64_Mode_URL)

  00034	83 7d 0c 01	 cmp	 DWORD PTR _mode$[ebp], 1
  00038	75 09		 jne	 SHORT $LN4@SelectDict

; 107  : 	{
; 108  : 		pDict = url_array;

  0003a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], OFFSET _url_array
  00041	eb 16		 jmp	 SHORT $LN5@SelectDict
$LN4@SelectDict:

; 109  : 	}
; 110  : 	else if (mode == Base64_Mode_PEM)

  00043	83 7d 0c 00	 cmp	 DWORD PTR _mode$[ebp], 0
  00047	75 09		 jne	 SHORT $LN2@SelectDict

; 111  : 	{
; 112  : 		pDict = pem_array;

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], OFFSET _pem_array

; 113  : 	}
; 114  : 	else

  00050	eb 07		 jmp	 SHORT $LN5@SelectDict
$LN2@SelectDict:

; 115  : 	{
; 116  : 		pDict = pem_array;

  00052	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], OFFSET _pem_array
$LN5@SelectDict:

; 117  : 	}
; 118  : 	*pOutput = pDict;

  00059	8b 45 08	 mov	 eax, DWORD PTR _pOutput$[ebp]
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _pDict$[ebp]
  0005f	89 08		 mov	 DWORD PTR [eax], ecx

; 119  : 	return *pOutput;

  00061	8b 45 08	 mov	 eax, DWORD PTR _pOutput$[ebp]
  00064	8b 00		 mov	 eax, DWORD PTR [eax]

; 120  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_SelectDict ENDP
_TEXT	ENDS
PUBLIC	_Base64Decrypt
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _Base64Decrypt
_TEXT	SEGMENT
_pDict$ = -80						; size = 4
_k$ = -68						; size = 4
_i$ = -56						; size = 4
_byte3$ = -41						; size = 1
_byte2$ = -29						; size = 1
_byte1$ = -17						; size = 1
_byte0$ = -5						; size = 1
_pInput$ = 8						; size = 4
_nSize$ = 12						; size = 4
_pOutput$ = 16						; size = 4
_mode$ = 20						; size = 4
_Base64Decrypt PROC					; COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd ec fe ff
	ff		 lea	 edi, DWORD PTR [ebp-276]
  00012	b9 45 00 00 00	 mov	 ecx, 69			; 00000045H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 225  : 	unsigned char byte0;
; 226  : 	unsigned char byte1;
; 227  : 	unsigned char byte2;
; 228  : 	unsigned char byte3;
; 229  : 	unsigned int i,k = 0;

  0001e	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0

; 230  : 	unsigned char* pDict = NULL;//ictionaries

  00025	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], 0

; 231  : 
; 232  : 	ReSelectDict(&pDict,mode);

  0002c	8b 45 14	 mov	 eax, DWORD PTR _mode$[ebp]
  0002f	50		 push	 eax
  00030	8d 4d b0	 lea	 ecx, DWORD PTR _pDict$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _ReSelectDict
  00039	83 c4 08	 add	 esp, 8

; 233  : 
; 234  : 	for (i=0; i<nSize; i+=4)//每次处理4个字节

  0003c	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00043	eb 09		 jmp	 SHORT $LN12@Base64Decr
$LN11@Base64Decr:
  00045	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  00048	83 c0 04	 add	 eax, 4
  0004b	89 45 c8	 mov	 DWORD PTR _i$[ebp], eax
$LN12@Base64Decr:
  0004e	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  00051	3b 45 0c	 cmp	 eax, DWORD PTR _nSize$[ebp]
  00054	0f 83 6c 01 00
	00		 jae	 $LN10@Base64Decr

; 235  : 	{
; 236  : 		//不足4个字节则停止解码
; 237  : 		if ((i + 4) > nSize)

  0005a	8b 45 c8	 mov	 eax, DWORD PTR _i$[ebp]
  0005d	83 c0 04	 add	 eax, 4
  00060	3b 45 0c	 cmp	 eax, DWORD PTR _nSize$[ebp]
  00063	76 05		 jbe	 SHORT $LN9@Base64Decr

; 238  : 		{
; 239  : 			break;

  00065	e9 5c 01 00 00	 jmp	 $LN10@Base64Decr
$LN9@Base64Decr:

; 240  : 		}
; 241  : 		//有这些值表示不符合规范
; 242  : 		/*
; 243  : 		if (*(pInput + i + 0) >= 0x7f ||
; 244  : 			*(pInput + i + 1) >= 0x7f ||
; 245  : 			*(pInput + i + 2) >= 0x7f ||
; 246  : 			*(pInput + i + 3) >= 0x7f)
; 247  : 		{
; 248  : 			break;
; 249  : 		}
; 250  : 		*/
; 251  : 		byte0 = *(pDict + *(pInput + i));

  0006a	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  0006d	03 45 c8	 add	 eax, DWORD PTR _i$[ebp]
  00070	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00073	8b 55 b0	 mov	 edx, DWORD PTR _pDict$[ebp]
  00076	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  00079	88 45 fb	 mov	 BYTE PTR _byte0$[ebp], al

; 252  : 		byte1 = *(pDict + *(pInput + i + 1));

  0007c	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  0007f	03 45 c8	 add	 eax, DWORD PTR _i$[ebp]
  00082	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00086	8b 55 b0	 mov	 edx, DWORD PTR _pDict$[ebp]
  00089	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  0008c	88 45 ef	 mov	 BYTE PTR _byte1$[ebp], al

; 253  : 		//为等号设为0
; 254  : 		if (*(pInput + i + 2) == ZEROCHAR)

  0008f	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  00092	03 45 c8	 add	 eax, DWORD PTR _i$[ebp]
  00095	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00099	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  0009c	75 06		 jne	 SHORT $LN8@Base64Decr

; 255  : 		{
; 256  : 			byte2 = 0;

  0009e	c6 45 e3 00	 mov	 BYTE PTR _byte2$[ebp], 0

; 257  : 		}
; 258  : 		else

  000a2	eb 13		 jmp	 SHORT $LN7@Base64Decr
$LN8@Base64Decr:

; 259  : 		{
; 260  : 			byte2 = *(pDict + *(pInput + i + 2));

  000a4	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  000a7	03 45 c8	 add	 eax, DWORD PTR _i$[ebp]
  000aa	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  000ae	8b 55 b0	 mov	 edx, DWORD PTR _pDict$[ebp]
  000b1	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  000b4	88 45 e3	 mov	 BYTE PTR _byte2$[ebp], al
$LN7@Base64Decr:

; 261  : 		}
; 262  : 
; 263  : 		//为等号设为0
; 264  : 		if (*(pInput + i + 3) == ZEROCHAR)

  000b7	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  000ba	03 45 c8	 add	 eax, DWORD PTR _i$[ebp]
  000bd	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000c1	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  000c4	75 06		 jne	 SHORT $LN6@Base64Decr

; 265  : 		{
; 266  : 			byte3 = 0;

  000c6	c6 45 d7 00	 mov	 BYTE PTR _byte3$[ebp], 0

; 267  : 		}
; 268  : 		else

  000ca	eb 13		 jmp	 SHORT $LN5@Base64Decr
$LN6@Base64Decr:

; 269  : 		{
; 270  : 			byte3 = *(pDict + *(pInput + i + 3));

  000cc	8b 45 08	 mov	 eax, DWORD PTR _pInput$[ebp]
  000cf	03 45 c8	 add	 eax, DWORD PTR _i$[ebp]
  000d2	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  000d6	8b 55 b0	 mov	 edx, DWORD PTR _pDict$[ebp]
  000d9	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  000dc	88 45 d7	 mov	 BYTE PTR _byte3$[ebp], al
$LN5@Base64Decr:

; 271  : 		}
; 272  : 
; 273  : 
; 274  : 		if ((byte2 == 0) && 
; 275  : 			(byte3 == 0))

  000df	0f b6 45 e3	 movzx	 eax, BYTE PTR _byte2$[ebp]
  000e3	85 c0		 test	 eax, eax
  000e5	75 2e		 jne	 SHORT $LN4@Base64Decr
  000e7	0f b6 45 d7	 movzx	 eax, BYTE PTR _byte3$[ebp]
  000eb	85 c0		 test	 eax, eax
  000ed	75 26		 jne	 SHORT $LN4@Base64Decr

; 276  : 		{
; 277  : 			//第一个字节后6位，第二个字节5,6位
; 278  : 			*(pOutput + k++) = (byte0 << 2) | (byte1 >> 4);

  000ef	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte0$[ebp]
  000f3	c1 e0 02	 shl	 eax, 2
  000f6	0f b6 4d ef	 movzx	 ecx, BYTE PTR _byte1$[ebp]
  000fa	c1 f9 04	 sar	 ecx, 4
  000fd	0b c1		 or	 eax, ecx
  000ff	8b 55 10	 mov	 edx, DWORD PTR _pOutput$[ebp]
  00102	03 55 bc	 add	 edx, DWORD PTR _k$[ebp]
  00105	88 02		 mov	 BYTE PTR [edx], al
  00107	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  0010a	83 c0 01	 add	 eax, 1
  0010d	89 45 bc	 mov	 DWORD PTR _k$[ebp], eax
  00110	e9 ac 00 00 00	 jmp	 $LN3@Base64Decr
$LN4@Base64Decr:

; 279  : 		} 
; 280  : 		else if (byte3 == 0) 

  00115	0f b6 45 d7	 movzx	 eax, BYTE PTR _byte3$[ebp]
  00119	85 c0		 test	 eax, eax
  0011b	75 44		 jne	 SHORT $LN2@Base64Decr

; 281  : 		{
; 282  : 			//第一个字节后6位，第二个字节5,6位
; 283  : 			*(pOutput + k++) = (byte0 << 2) | (byte1 >> 4);

  0011d	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte0$[ebp]
  00121	c1 e0 02	 shl	 eax, 2
  00124	0f b6 4d ef	 movzx	 ecx, BYTE PTR _byte1$[ebp]
  00128	c1 f9 04	 sar	 ecx, 4
  0012b	0b c1		 or	 eax, ecx
  0012d	8b 55 10	 mov	 edx, DWORD PTR _pOutput$[ebp]
  00130	03 55 bc	 add	 edx, DWORD PTR _k$[ebp]
  00133	88 02		 mov	 BYTE PTR [edx], al
  00135	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  00138	83 c0 01	 add	 eax, 1
  0013b	89 45 bc	 mov	 DWORD PTR _k$[ebp], eax

; 284  : 
; 285  : 			//第二个字节后4位，第三个字节3,4,5,6位
; 286  : 			*(pOutput + k++) = (byte1 << 4) | (byte2 >> 2);

  0013e	0f b6 45 ef	 movzx	 eax, BYTE PTR _byte1$[ebp]
  00142	c1 e0 04	 shl	 eax, 4
  00145	0f b6 4d e3	 movzx	 ecx, BYTE PTR _byte2$[ebp]
  00149	c1 f9 02	 sar	 ecx, 2
  0014c	0b c1		 or	 eax, ecx
  0014e	8b 55 10	 mov	 edx, DWORD PTR _pOutput$[ebp]
  00151	03 55 bc	 add	 edx, DWORD PTR _k$[ebp]
  00154	88 02		 mov	 BYTE PTR [edx], al
  00156	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  00159	83 c0 01	 add	 eax, 1
  0015c	89 45 bc	 mov	 DWORD PTR _k$[ebp], eax

; 287  : 		}
; 288  : 		else

  0015f	eb 60		 jmp	 SHORT $LN3@Base64Decr
$LN2@Base64Decr:

; 289  : 		{
; 290  : 			//第一个字节后6位，第二个字节5,6位
; 291  : 			*(pOutput + k++) = (byte0 << 2) | (byte1 >> 4);

  00161	0f b6 45 fb	 movzx	 eax, BYTE PTR _byte0$[ebp]
  00165	c1 e0 02	 shl	 eax, 2
  00168	0f b6 4d ef	 movzx	 ecx, BYTE PTR _byte1$[ebp]
  0016c	c1 f9 04	 sar	 ecx, 4
  0016f	0b c1		 or	 eax, ecx
  00171	8b 55 10	 mov	 edx, DWORD PTR _pOutput$[ebp]
  00174	03 55 bc	 add	 edx, DWORD PTR _k$[ebp]
  00177	88 02		 mov	 BYTE PTR [edx], al
  00179	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  0017c	83 c0 01	 add	 eax, 1
  0017f	89 45 bc	 mov	 DWORD PTR _k$[ebp], eax

; 292  : 
; 293  : 			//第二个字节后4位，第三个字节3,4,5,6位
; 294  : 			*(pOutput + k++) = (byte1 << 4) | (byte2 >> 2);

  00182	0f b6 45 ef	 movzx	 eax, BYTE PTR _byte1$[ebp]
  00186	c1 e0 04	 shl	 eax, 4
  00189	0f b6 4d e3	 movzx	 ecx, BYTE PTR _byte2$[ebp]
  0018d	c1 f9 02	 sar	 ecx, 2
  00190	0b c1		 or	 eax, ecx
  00192	8b 55 10	 mov	 edx, DWORD PTR _pOutput$[ebp]
  00195	03 55 bc	 add	 edx, DWORD PTR _k$[ebp]
  00198	88 02		 mov	 BYTE PTR [edx], al
  0019a	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  0019d	83 c0 01	 add	 eax, 1
  001a0	89 45 bc	 mov	 DWORD PTR _k$[ebp], eax

; 295  : 
; 296  : 			//第三个字节后2位，第四个字节后6位
; 297  : 			*(pOutput + k++) = (byte2 << 6) | byte3;

  001a3	0f b6 45 e3	 movzx	 eax, BYTE PTR _byte2$[ebp]
  001a7	c1 e0 06	 shl	 eax, 6
  001aa	0f b6 4d d7	 movzx	 ecx, BYTE PTR _byte3$[ebp]
  001ae	0b c1		 or	 eax, ecx
  001b0	8b 55 10	 mov	 edx, DWORD PTR _pOutput$[ebp]
  001b3	03 55 bc	 add	 edx, DWORD PTR _k$[ebp]
  001b6	88 02		 mov	 BYTE PTR [edx], al
  001b8	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]
  001bb	83 c0 01	 add	 eax, 1
  001be	89 45 bc	 mov	 DWORD PTR _k$[ebp], eax
$LN3@Base64Decr:

; 298  : 		}
; 299  : 	}

  001c1	e9 7f fe ff ff	 jmp	 $LN11@Base64Decr
$LN10@Base64Decr:

; 300  : 	return k;

  001c6	8b 45 bc	 mov	 eax, DWORD PTR _k$[ebp]

; 301  : }

  001c9	52		 push	 edx
  001ca	8b cd		 mov	 ecx, ebp
  001cc	50		 push	 eax
  001cd	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@Base64Decr
  001d3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001d8	58		 pop	 eax
  001d9	5a		 pop	 edx
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx
  001dd	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  001e3	3b ec		 cmp	 ebp, esp
  001e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c3		 ret	 0
  001ee	8b ff		 npad	 2
$LN17@Base64Decr:
  001f0	01 00 00 00	 DD	 1
  001f4	00 00 00 00	 DD	 $LN16@Base64Decr
$LN16@Base64Decr:
  001f8	b0 ff ff ff	 DD	 -80			; ffffffb0H
  001fc	04 00 00 00	 DD	 4
  00200	00 00 00 00	 DD	 $LN15@Base64Decr
$LN15@Base64Decr:
  00204	70		 DB	 112			; 00000070H
  00205	44		 DB	 68			; 00000044H
  00206	69		 DB	 105			; 00000069H
  00207	63		 DB	 99			; 00000063H
  00208	74		 DB	 116			; 00000074H
  00209	00		 DB	 0
_Base64Decrypt ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _ReSelectDict
_TEXT	SEGMENT
_pDict$ = -8						; size = 4
_pOutput$ = 8						; size = 4
_mode$ = 12						; size = 4
_ReSelectDict PROC					; COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 126  : 	unsigned char* pDict = NULL;//ictionaries

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], 0

; 127  : 	/**确定字典*/
; 128  : 	if (mode == Base64_Mode_REG)

  00025	83 7d 0c 02	 cmp	 DWORD PTR _mode$[ebp], 2
  00029	75 09		 jne	 SHORT $LN6@ReSelectDi

; 129  : 	{
; 130  : 		pDict = re_regular_array;

  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], OFFSET _re_regular_array
  00032	eb 25		 jmp	 SHORT $LN5@ReSelectDi
$LN6@ReSelectDi:

; 131  : 	}
; 132  : 	else if (mode == Base64_Mode_URL)

  00034	83 7d 0c 01	 cmp	 DWORD PTR _mode$[ebp], 1
  00038	75 09		 jne	 SHORT $LN4@ReSelectDi

; 133  : 	{
; 134  : 		pDict = re_url_array;

  0003a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], OFFSET _re_url_array
  00041	eb 16		 jmp	 SHORT $LN5@ReSelectDi
$LN4@ReSelectDi:

; 135  : 	}
; 136  : 	else if (mode == Base64_Mode_PEM)

  00043	83 7d 0c 00	 cmp	 DWORD PTR _mode$[ebp], 0
  00047	75 09		 jne	 SHORT $LN2@ReSelectDi

; 137  : 	{
; 138  : 		pDict = re_pem_array;

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], OFFSET _re_pem_array

; 139  : 	}
; 140  : 	else

  00050	eb 07		 jmp	 SHORT $LN5@ReSelectDi
$LN2@ReSelectDi:

; 141  : 	{
; 142  : 		pDict = re_pem_array;

  00052	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pDict$[ebp], OFFSET _re_pem_array
$LN5@ReSelectDi:

; 143  : 	}
; 144  : 	*pOutput = pDict;

  00059	8b 45 08	 mov	 eax, DWORD PTR _pOutput$[ebp]
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _pDict$[ebp]
  0005f	89 08		 mov	 DWORD PTR [eax], ecx

; 145  : 	return *pOutput;

  00061	8b 45 08	 mov	 eax, DWORD PTR _pOutput$[ebp]
  00064	8b 00		 mov	 eax, DWORD PTR [eax]

; 146  : }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_ReSelectDict ENDP
_TEXT	ENDS
END

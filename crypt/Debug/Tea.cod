; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\windows\belial\crypt\Tea.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_TeaInit
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File d:\windows\belial\crypt\tea.c
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _TeaInit
_TEXT	SEGMENT
_context$ = 8						; size = 4
_TeaInit PROC						; COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 63   : 	//memset(k,0,MAXKEYLEN);//16个字节长度
; 64   : 	//memcpy(k,pKey,(nLen > MAXKEYLEN) ? MAXKEYLEN : nLen);
; 65   : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_TeaInit ENDP
_TEXT	ENDS
PUBLIC	_TeaSetKey
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _TeaSetKey
_TEXT	SEGMENT
tv69 = -196						; size = 4
_context$ = 8						; size = 4
_pKey$ = 12						; size = 4
_nLen$ = 16						; size = 4
_TeaSetKey PROC						; COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 69   : 	memset(context->key,0,MAXKEYLEN);//16个字节长度

  0001e	6a 10		 push	 16			; 00000010H
  00020	6a 00		 push	 0
  00022	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _memset
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 70   : 	memcpy(context->key,pKey,(nLen > MAXKEYLEN) ? MAXKEYLEN : nLen);

  0002e	83 7d 10 10	 cmp	 DWORD PTR _nLen$[ebp], 16 ; 00000010H
  00032	76 0c		 jbe	 SHORT $LN3@TeaSetKey
  00034	c7 85 3c ff ff
	ff 10 00 00 00	 mov	 DWORD PTR tv69[ebp], 16	; 00000010H
  0003e	eb 09		 jmp	 SHORT $LN4@TeaSetKey
$LN3@TeaSetKey:
  00040	8b 45 10	 mov	 eax, DWORD PTR _nLen$[ebp]
  00043	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN4@TeaSetKey:
  00049	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  0004f	51		 push	 ecx
  00050	8b 55 0c	 mov	 edx, DWORD PTR _pKey$[ebp]
  00053	52		 push	 edx
  00054	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _memcpy
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 71   : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
_TeaSetKey ENDP
_TEXT	ENDS
PUBLIC	_TeaEncrypt
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _TeaEncrypt
_TEXT	SEGMENT
tv77 = -232						; size = 4
tv69 = -232						; size = 4
_pV$ = -32						; size = 4
_i$ = -20						; size = 4
_loop$ = -8						; size = 4
_context$ = 8						; size = 4
_pInput$ = 12						; size = 4
_nSize$ = 16						; size = 4
_pOutput$ = 20						; size = 4
_TeaEncrypt PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 161  : 	int loop,i;
; 162  : 	int* pV;
; 163  : 	loop = CHECKDIV8(nSize) / 8;//共要计算的次数

  0001e	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00021	83 e0 07	 and	 eax, 7
  00024	74 16		 je	 SHORT $LN11@TeaEncrypt
  00026	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00029	83 c1 08	 add	 ecx, 8
  0002c	8b 55 10	 mov	 edx, DWORD PTR _nSize$[ebp]
  0002f	83 e2 07	 and	 edx, 7
  00032	2b ca		 sub	 ecx, edx
  00034	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], ecx
  0003a	eb 09		 jmp	 SHORT $LN12@TeaEncrypt
$LN11@TeaEncrypt:
  0003c	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  0003f	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
$LN12@TeaEncrypt:
  00045	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  0004b	c1 e9 03	 shr	 ecx, 3
  0004e	89 4d f8	 mov	 DWORD PTR _loop$[ebp], ecx

; 164  : 	memset(pOutput,0,CHECKDIV8(nSize));//这种操作最后放到函数外

  00051	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00054	83 e0 07	 and	 eax, 7
  00057	74 16		 je	 SHORT $LN13@TeaEncrypt
  00059	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  0005c	83 c1 08	 add	 ecx, 8
  0005f	8b 55 10	 mov	 edx, DWORD PTR _nSize$[ebp]
  00062	83 e2 07	 and	 edx, 7
  00065	2b ca		 sub	 ecx, edx
  00067	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv77[ebp], ecx
  0006d	eb 09		 jmp	 SHORT $LN14@TeaEncrypt
$LN13@TeaEncrypt:
  0006f	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00072	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
$LN14@TeaEncrypt:
  00078	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv77[ebp]
  0007e	51		 push	 ecx
  0007f	6a 00		 push	 0
  00081	8b 55 14	 mov	 edx, DWORD PTR _pOutput$[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _memset
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  : 	memcpy(pOutput,pInput,nSize);

  0008d	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00090	50		 push	 eax
  00091	8b 4d 0c	 mov	 ecx, DWORD PTR _pInput$[ebp]
  00094	51		 push	 ecx
  00095	8b 55 14	 mov	 edx, DWORD PTR _pOutput$[ebp]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 _memcpy
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 166  : 	pV = (int*)pOutput;

  000a1	8b 45 14	 mov	 eax, DWORD PTR _pOutput$[ebp]
  000a4	89 45 e0	 mov	 DWORD PTR _pV$[ebp], eax

; 167  : 	if (context->mode == Tea_Mode)

  000a7	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000aa	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000ae	75 36		 jne	 SHORT $LN8@TeaEncrypt

; 168  : 	{
; 169  : 		for (i=0; i<loop;i++)

  000b0	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000b7	eb 09		 jmp	 SHORT $LN7@TeaEncrypt
$LN6@TeaEncrypt:
  000b9	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000bc	83 c0 01	 add	 eax, 1
  000bf	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN7@TeaEncrypt:
  000c2	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000c5	3b 45 f8	 cmp	 eax, DWORD PTR _loop$[ebp]
  000c8	7d 1a		 jge	 SHORT $LN5@TeaEncrypt

; 170  : 		{
; 171  : 			TeaEncode(context,pV + (i * 2));

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000cd	d1 e0		 shl	 eax, 1
  000cf	8b 4d e0	 mov	 ecx, DWORD PTR _pV$[ebp]
  000d2	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000d5	52		 push	 edx
  000d6	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _TeaEncode
  000df	83 c4 08	 add	 esp, 8

; 172  : 		}

  000e2	eb d5		 jmp	 SHORT $LN6@TeaEncrypt
$LN5@TeaEncrypt:

; 173  : 	}
; 174  : 	else if (context->mode == XTea_Mode)

  000e4	eb 40		 jmp	 SHORT $LN9@TeaEncrypt
$LN8@TeaEncrypt:
  000e6	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000e9	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  000ed	75 18		 jne	 SHORT $LN3@TeaEncrypt

; 175  : 	{
; 176  : 		XXTeaEncode(context,pV,loop *  2);

  000ef	8b 45 f8	 mov	 eax, DWORD PTR _loop$[ebp]
  000f2	d1 e0		 shl	 eax, 1
  000f4	50		 push	 eax
  000f5	8b 4d e0	 mov	 ecx, DWORD PTR _pV$[ebp]
  000f8	51		 push	 ecx
  000f9	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 _XXTeaEncode
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH
  00105	eb 1f		 jmp	 SHORT $LN9@TeaEncrypt
$LN3@TeaEncrypt:

; 177  : 	}
; 178  : 	else if (context->mode == XXTea_Mode)

  00107	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  0010a	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  0010e	75 16		 jne	 SHORT $LN9@TeaEncrypt

; 179  : 	{
; 180  : 		XXTeaEncode(context,pV,loop *  2);

  00110	8b 45 f8	 mov	 eax, DWORD PTR _loop$[ebp]
  00113	d1 e0		 shl	 eax, 1
  00115	50		 push	 eax
  00116	8b 4d e0	 mov	 ecx, DWORD PTR _pV$[ebp]
  00119	51		 push	 ecx
  0011a	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  0011d	52		 push	 edx
  0011e	e8 00 00 00 00	 call	 _XXTeaEncode
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@TeaEncrypt:

; 181  : 	}
; 182  : 	return;
; 183  : }

  00126	5f		 pop	 edi
  00127	5e		 pop	 esi
  00128	5b		 pop	 ebx
  00129	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  0012f	3b ec		 cmp	 ebp, esp
  00131	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
_TeaEncrypt ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _TeaEncode
_TEXT	SEGMENT
_i$ = -44						; size = 4
_sum$ = -32						; size = 4
_v1$ = -20						; size = 4
_v0$ = -8						; size = 4
_context$ = 8						; size = 4
_v$ = 12						; size = 4
_TeaEncode PROC						; COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 75   : 	int v0 = v[0];

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d f8	 mov	 DWORD PTR _v0$[ebp], ecx

; 76   : 	int v1 = v[1];

  00026	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	89 4d ec	 mov	 DWORD PTR _v1$[ebp], ecx

; 77   : 	unsigned int sum=0;

  0002f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _sum$[ebp], 0

; 78   : 	int i;
; 79   : 	//32次置换
; 80   : 	for (i=0; i<32; i++)

  00036	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN3@TeaEncode
$LN2@TeaEncode:
  0003f	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN3@TeaEncode:
  00048	83 7d d4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  0004c	7d 5c		 jge	 SHORT $LN1@TeaEncode

; 81   : 	{
; 82   : 		sum += TEADELTA;

  0004e	8b 45 e0	 mov	 eax, DWORD PTR _sum$[ebp]
  00051	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  00056	89 45 e0	 mov	 DWORD PTR _sum$[ebp], eax

; 83   : 		v0 += ((v1<<4) + context->key[0]) ^ (v1 + sum) ^ ((v1>>5) + context->key[1]);

  00059	8b 45 ec	 mov	 eax, DWORD PTR _v1$[ebp]
  0005c	c1 e0 04	 shl	 eax, 4
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _context$[ebp]
  00062	03 01		 add	 eax, DWORD PTR [ecx]
  00064	8b 55 ec	 mov	 edx, DWORD PTR _v1$[ebp]
  00067	03 55 e0	 add	 edx, DWORD PTR _sum$[ebp]
  0006a	33 c2		 xor	 eax, edx
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _v1$[ebp]
  0006f	c1 f9 05	 sar	 ecx, 5
  00072	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  00075	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00078	33 c1		 xor	 eax, ecx
  0007a	03 45 f8	 add	 eax, DWORD PTR _v0$[ebp]
  0007d	89 45 f8	 mov	 DWORD PTR _v0$[ebp], eax

; 84   : 		v1 += ((v0<<4) + context->key[2]) ^ (v0 + sum) ^ ((v0>>5) + context->key[3]);

  00080	8b 45 f8	 mov	 eax, DWORD PTR _v0$[ebp]
  00083	c1 e0 04	 shl	 eax, 4
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _context$[ebp]
  00089	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  0008c	8b 55 f8	 mov	 edx, DWORD PTR _v0$[ebp]
  0008f	03 55 e0	 add	 edx, DWORD PTR _sum$[ebp]
  00092	33 c2		 xor	 eax, edx
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _v0$[ebp]
  00097	c1 f9 05	 sar	 ecx, 5
  0009a	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  0009d	03 4a 0c	 add	 ecx, DWORD PTR [edx+12]
  000a0	33 c1		 xor	 eax, ecx
  000a2	03 45 ec	 add	 eax, DWORD PTR _v1$[ebp]
  000a5	89 45 ec	 mov	 DWORD PTR _v1$[ebp], eax

; 85   : 	}

  000a8	eb 95		 jmp	 SHORT $LN2@TeaEncode
$LN1@TeaEncode:

; 86   : 	v[0] = v0;

  000aa	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _v0$[ebp]
  000b0	89 08		 mov	 DWORD PTR [eax], ecx

; 87   : 	v[1] = v1;

  000b2	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  000b5	8b 4d ec	 mov	 ecx, DWORD PTR _v1$[ebp]
  000b8	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 88   : }

  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
_TeaEncode ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _XXTeaEncode
_TEXT	SEGMENT
tv153 = -280						; size = 4
tv133 = -280						; size = 4
tv72 = -280						; size = 4
_z$ = -80						; size = 4
_len$ = -68						; size = 4
_sum$ = -56						; size = 4
_y$ = -44						; size = 4
_e$ = -32						; size = 4
_q$ = -20						; size = 4
_p$ = -8						; size = 4
_context$ = 8						; size = 4
_v$ = 12						; size = 4
_nSize$ = 16						; size = 4
_XXTeaEncode PROC					; COMDAT

; 110  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 111  :     unsigned int p, q ;
; 112  : 	unsigned int e; 
; 113  : 	unsigned int y = v[0];//第一个数

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d d4	 mov	 DWORD PTR _y$[ebp], ecx

; 114  : 	unsigned int sum = 0;

  00026	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _sum$[ebp], 0

; 115  : 	unsigned int len = nSize - 1; 

  0002d	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00030	83 e8 01	 sub	 eax, 1
  00033	89 45 bc	 mov	 DWORD PTR _len$[ebp], eax

; 116  : 	unsigned int z = v[len];//最后一个数

  00036	8b 45 bc	 mov	 eax, DWORD PTR _len$[ebp]
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0003c	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0003f	89 55 b0	 mov	 DWORD PTR _z$[ebp], edx

; 117  : 
; 118  : 	if (nSize > 1) {

  00042	83 7d 10 01	 cmp	 DWORD PTR _nSize$[ebp], 1
  00046	0f 86 59 01 00
	00		 jbe	 $LN7@XXTeaEncod

; 119  : 		q = 6 + 52 / nSize;

  0004c	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
  00051	33 d2		 xor	 edx, edx
  00053	f7 75 10	 div	 DWORD PTR _nSize$[ebp]
  00056	83 c0 06	 add	 eax, 6
  00059	89 45 ec	 mov	 DWORD PTR _q$[ebp], eax
$LN5@XXTeaEncod:

; 120  : 		while (q-- > 0) {//q轮加密,这样看起来越短加密轮数越多

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _q$[ebp]
  0005f	8b 4d ec	 mov	 ecx, DWORD PTR _q$[ebp]
  00062	83 e9 01	 sub	 ecx, 1
  00065	89 4d ec	 mov	 DWORD PTR _q$[ebp], ecx
  00068	85 c0		 test	 eax, eax
  0006a	76 0c		 jbe	 SHORT $LN9@XXTeaEncod
  0006c	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv72[ebp], 1
  00076	eb 0a		 jmp	 SHORT $LN10@XXTeaEncod
$LN9@XXTeaEncod:
  00078	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv72[ebp], 0
$LN10@XXTeaEncod:
  00082	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR tv72[ebp], 0
  00089	0f 84 16 01 00
	00		 je	 $LN7@XXTeaEncod

; 121  : 			sum += TEADELTA;

  0008f	8b 45 c8	 mov	 eax, DWORD PTR _sum$[ebp]
  00092	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  00097	89 45 c8	 mov	 DWORD PTR _sum$[ebp], eax

; 122  : 			e = (sum >> 2) & 3;

  0009a	8b 45 c8	 mov	 eax, DWORD PTR _sum$[ebp]
  0009d	c1 e8 02	 shr	 eax, 2
  000a0	83 e0 03	 and	 eax, 3
  000a3	89 45 e0	 mov	 DWORD PTR _e$[ebp], eax

; 123  : 			for (p=0; p < len; p++)

  000a6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  000ad	eb 09		 jmp	 SHORT $LN3@XXTeaEncod
$LN2@XXTeaEncod:
  000af	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  000b2	83 c0 01	 add	 eax, 1
  000b5	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax
$LN3@XXTeaEncod:
  000b8	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  000bb	3b 45 bc	 cmp	 eax, DWORD PTR _len$[ebp]
  000be	73 75		 jae	 SHORT $LN1@XXTeaEncod

; 124  : 			{
; 125  : 				y = v[p+1],z = v[p] += MOVOP;//

  000c0	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  000c3	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  000c6	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  000ca	89 55 d4	 mov	 DWORD PTR _y$[ebp], edx
  000cd	8b 45 b0	 mov	 eax, DWORD PTR _z$[ebp]
  000d0	c1 e8 05	 shr	 eax, 5
  000d3	8b 4d d4	 mov	 ecx, DWORD PTR _y$[ebp]
  000d6	c1 e1 02	 shl	 ecx, 2
  000d9	33 c1		 xor	 eax, ecx
  000db	8b 55 d4	 mov	 edx, DWORD PTR _y$[ebp]
  000de	c1 ea 03	 shr	 edx, 3
  000e1	8b 4d b0	 mov	 ecx, DWORD PTR _z$[ebp]
  000e4	c1 e1 04	 shl	 ecx, 4
  000e7	33 d1		 xor	 edx, ecx
  000e9	03 c2		 add	 eax, edx
  000eb	8b 55 c8	 mov	 edx, DWORD PTR _sum$[ebp]
  000ee	33 55 d4	 xor	 edx, DWORD PTR _y$[ebp]
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  000f4	83 e1 03	 and	 ecx, 3
  000f7	33 4d e0	 xor	 ecx, DWORD PTR _e$[ebp]
  000fa	8b 75 08	 mov	 esi, DWORD PTR _context$[ebp]
  000fd	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  00100	33 4d b0	 xor	 ecx, DWORD PTR _z$[ebp]
  00103	03 d1		 add	 edx, ecx
  00105	33 c2		 xor	 eax, edx
  00107	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  0010a	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0010d	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00110	03 d0		 add	 edx, eax
  00112	89 95 e8 fe ff
	ff		 mov	 DWORD PTR tv133[ebp], edx
  00118	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0011e	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv133[ebp]
  00124	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  00127	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv133[ebp]
  0012d	89 45 b0	 mov	 DWORD PTR _z$[ebp], eax

; 126  : 			}

  00130	e9 7a ff ff ff	 jmp	 $LN2@XXTeaEncod
$LN1@XXTeaEncod:

; 127  : 			y = v[0];

  00135	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00138	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013a	89 4d d4	 mov	 DWORD PTR _y$[ebp], ecx

; 128  : 			z = v[len] += MOVOP;

  0013d	8b 45 b0	 mov	 eax, DWORD PTR _z$[ebp]
  00140	c1 e8 05	 shr	 eax, 5
  00143	8b 4d d4	 mov	 ecx, DWORD PTR _y$[ebp]
  00146	c1 e1 02	 shl	 ecx, 2
  00149	33 c1		 xor	 eax, ecx
  0014b	8b 55 d4	 mov	 edx, DWORD PTR _y$[ebp]
  0014e	c1 ea 03	 shr	 edx, 3
  00151	8b 4d b0	 mov	 ecx, DWORD PTR _z$[ebp]
  00154	c1 e1 04	 shl	 ecx, 4
  00157	33 d1		 xor	 edx, ecx
  00159	03 c2		 add	 eax, edx
  0015b	8b 55 c8	 mov	 edx, DWORD PTR _sum$[ebp]
  0015e	33 55 d4	 xor	 edx, DWORD PTR _y$[ebp]
  00161	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  00164	83 e1 03	 and	 ecx, 3
  00167	33 4d e0	 xor	 ecx, DWORD PTR _e$[ebp]
  0016a	8b 75 08	 mov	 esi, DWORD PTR _context$[ebp]
  0016d	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  00170	33 4d b0	 xor	 ecx, DWORD PTR _z$[ebp]
  00173	03 d1		 add	 edx, ecx
  00175	33 c2		 xor	 eax, edx
  00177	8b 55 bc	 mov	 edx, DWORD PTR _len$[ebp]
  0017a	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0017d	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00180	03 d0		 add	 edx, eax
  00182	89 95 e8 fe ff
	ff		 mov	 DWORD PTR tv153[ebp], edx
  00188	8b 45 bc	 mov	 eax, DWORD PTR _len$[ebp]
  0018b	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0018e	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv153[ebp]
  00194	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  00197	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv153[ebp]
  0019d	89 45 b0	 mov	 DWORD PTR _z$[ebp], eax

; 129  : 		}

  001a0	e9 b7 fe ff ff	 jmp	 $LN5@XXTeaEncod
$LN7@XXTeaEncod:

; 130  : 	}
; 131  : }

  001a5	5f		 pop	 edi
  001a6	5e		 pop	 esi
  001a7	5b		 pop	 ebx
  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
_XXTeaEncode ENDP
_TEXT	ENDS
PUBLIC	_TeaDecrypt
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _TeaDecrypt
_TEXT	SEGMENT
_pV$ = -32						; size = 4
_i$ = -20						; size = 4
_loop$ = -8						; size = 4
_context$ = 8						; size = 4
_pInput$ = 12						; size = 4
_nSize$ = 16						; size = 4
_pOutput$ = 20						; size = 4
_TeaDecrypt PROC					; COMDAT

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 187  : 	int loop,i;
; 188  : 	int* pV;
; 189  : 	//不是8的倍数就不用来解密了
; 190  : 	if ((nSize % 8) != 0)

  0001e	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00021	33 d2		 xor	 edx, edx
  00023	b9 08 00 00 00	 mov	 ecx, 8
  00028	f7 f1		 div	 ecx
  0002a	85 d2		 test	 edx, edx
  0002c	74 05		 je	 SHORT $LN9@TeaDecrypt

; 191  : 	{
; 192  : 		return;

  0002e	e9 b4 00 00 00	 jmp	 $LN10@TeaDecrypt
$LN9@TeaDecrypt:

; 193  : 	}
; 194  : 	loop = nSize / 8;//共要计算的次数

  00033	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00036	c1 e8 03	 shr	 eax, 3
  00039	89 45 f8	 mov	 DWORD PTR _loop$[ebp], eax

; 195  : 	memset(pOutput,0,nSize);//这种操作最后放到函数外

  0003c	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  0003f	50		 push	 eax
  00040	6a 00		 push	 0
  00042	8b 4d 14	 mov	 ecx, DWORD PTR _pOutput$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 _memset
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 196  : 	memcpy(pOutput,pInput,nSize);

  0004e	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _pInput$[ebp]
  00055	51		 push	 ecx
  00056	8b 55 14	 mov	 edx, DWORD PTR _pOutput$[ebp]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 _memcpy
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 197  : 	pV = (int*)pOutput;

  00062	8b 45 14	 mov	 eax, DWORD PTR _pOutput$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR _pV$[ebp], eax

; 198  : 	if (context->mode == Tea_Mode)

  00068	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  0006b	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0006f	75 36		 jne	 SHORT $LN8@TeaDecrypt

; 199  : 	{
; 200  : 		for (i=0; i<loop;i++)

  00071	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00078	eb 09		 jmp	 SHORT $LN7@TeaDecrypt
$LN6@TeaDecrypt:
  0007a	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	83 c0 01	 add	 eax, 1
  00080	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN7@TeaDecrypt:
  00083	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00086	3b 45 f8	 cmp	 eax, DWORD PTR _loop$[ebp]
  00089	7d 1a		 jge	 SHORT $LN5@TeaDecrypt

; 201  : 		{
; 202  : 			TeaDecode(context,pV + (i * 2));

  0008b	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0008e	d1 e0		 shl	 eax, 1
  00090	8b 4d e0	 mov	 ecx, DWORD PTR _pV$[ebp]
  00093	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00096	52		 push	 edx
  00097	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _TeaDecode
  000a0	83 c4 08	 add	 esp, 8

; 203  : 		}

  000a3	eb d5		 jmp	 SHORT $LN6@TeaDecrypt
$LN5@TeaDecrypt:

; 204  : 	}
; 205  : 	else if (context->mode == XTea_Mode)

  000a5	eb 40		 jmp	 SHORT $LN10@TeaDecrypt
$LN8@TeaDecrypt:
  000a7	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000aa	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  000ae	75 18		 jne	 SHORT $LN3@TeaDecrypt

; 206  : 	{
; 207  : 		XXTeaDecode(context,pV,loop *  2);

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _loop$[ebp]
  000b3	d1 e0		 shl	 eax, 1
  000b5	50		 push	 eax
  000b6	8b 4d e0	 mov	 ecx, DWORD PTR _pV$[ebp]
  000b9	51		 push	 ecx
  000ba	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _XXTeaDecode
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	eb 1f		 jmp	 SHORT $LN10@TeaDecrypt
$LN3@TeaDecrypt:

; 208  : 	}
; 209  : 	else if (context->mode == XXTea_Mode)

  000c8	8b 45 08	 mov	 eax, DWORD PTR _context$[ebp]
  000cb	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  000cf	75 16		 jne	 SHORT $LN10@TeaDecrypt

; 210  : 	{
; 211  : 		XXTeaDecode(context,pV,loop *  2);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR _loop$[ebp]
  000d4	d1 e0		 shl	 eax, 1
  000d6	50		 push	 eax
  000d7	8b 4d e0	 mov	 ecx, DWORD PTR _pV$[ebp]
  000da	51		 push	 ecx
  000db	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 _XXTeaDecode
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@TeaDecrypt:

; 212  : 	}
; 213  : 	return;
; 214  : }

  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_TeaDecrypt ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _TeaDecode
_TEXT	SEGMENT
_i$ = -44						; size = 4
_sum$ = -32						; size = 4
_v1$ = -20						; size = 4
_v0$ = -8						; size = 4
_context$ = 8						; size = 4
_v$ = 12						; size = 4
_TeaDecode PROC						; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 92   : 	int v0 = v[0];

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d f8	 mov	 DWORD PTR _v0$[ebp], ecx

; 93   : 	int v1 = v[1];

  00026	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	89 4d ec	 mov	 DWORD PTR _v1$[ebp], ecx

; 94   : 	unsigned int sum=0;

  0002f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _sum$[ebp], 0

; 95   : 	int i;
; 96   : 	sum = TEASUM;

  00036	c7 45 e0 20 37
	ef c6		 mov	 DWORD PTR _sum$[ebp], -957401312 ; c6ef3720H

; 97   : 	for (i=0; i<32; i++) 

  0003d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00044	eb 09		 jmp	 SHORT $LN3@TeaDecode
$LN2@TeaDecode:
  00046	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00049	83 c0 01	 add	 eax, 1
  0004c	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN3@TeaDecode:
  0004f	83 7d d4 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00053	7d 60		 jge	 SHORT $LN1@TeaDecode

; 98   : 	{
; 99   : 		v1 -= ((v0<<4) + context->key[2]) ^ (v0 + sum) ^ ((v0>>5) + context->key[3]);

  00055	8b 45 f8	 mov	 eax, DWORD PTR _v0$[ebp]
  00058	c1 e0 04	 shl	 eax, 4
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _context$[ebp]
  0005e	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00061	8b 55 f8	 mov	 edx, DWORD PTR _v0$[ebp]
  00064	03 55 e0	 add	 edx, DWORD PTR _sum$[ebp]
  00067	33 c2		 xor	 eax, edx
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _v0$[ebp]
  0006c	c1 f9 05	 sar	 ecx, 5
  0006f	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  00072	03 4a 0c	 add	 ecx, DWORD PTR [edx+12]
  00075	33 c1		 xor	 eax, ecx
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _v1$[ebp]
  0007a	2b c8		 sub	 ecx, eax
  0007c	89 4d ec	 mov	 DWORD PTR _v1$[ebp], ecx

; 100  : 		v0 -= ((v1<<4) + context->key[0]) ^ (v1 + sum) ^ ((v1>>5) + context->key[1]);

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _v1$[ebp]
  00082	c1 e0 04	 shl	 eax, 4
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _context$[ebp]
  00088	03 01		 add	 eax, DWORD PTR [ecx]
  0008a	8b 55 ec	 mov	 edx, DWORD PTR _v1$[ebp]
  0008d	03 55 e0	 add	 edx, DWORD PTR _sum$[ebp]
  00090	33 c2		 xor	 eax, edx
  00092	8b 4d ec	 mov	 ecx, DWORD PTR _v1$[ebp]
  00095	c1 f9 05	 sar	 ecx, 5
  00098	8b 55 08	 mov	 edx, DWORD PTR _context$[ebp]
  0009b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0009e	33 c1		 xor	 eax, ecx
  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _v0$[ebp]
  000a3	2b c8		 sub	 ecx, eax
  000a5	89 4d f8	 mov	 DWORD PTR _v0$[ebp], ecx

; 101  : 		sum -= TEADELTA;

  000a8	8b 45 e0	 mov	 eax, DWORD PTR _sum$[ebp]
  000ab	05 47 86 c8 61	 add	 eax, 1640531527		; 61c88647H
  000b0	89 45 e0	 mov	 DWORD PTR _sum$[ebp], eax

; 102  : 	}

  000b3	eb 91		 jmp	 SHORT $LN2@TeaDecode
$LN1@TeaDecode:

; 103  : 	v[0] = v0;

  000b5	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _v0$[ebp]
  000bb	89 08		 mov	 DWORD PTR [eax], ecx

; 104  : 	v[1] = v1;

  000bd	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  000c0	8b 4d ec	 mov	 ecx, DWORD PTR _v1$[ebp]
  000c3	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 105  : }

  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
_TeaDecode ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _XXTeaDecode
_TEXT	SEGMENT
tv130 = -280						; size = 4
_z$ = -80						; size = 4
_len$ = -68						; size = 4
_sum$ = -56						; size = 4
_y$ = -44						; size = 4
_e$ = -32						; size = 4
_q$ = -20						; size = 4
_p$ = -8						; size = 4
_context$ = 8						; size = 4
_v$ = 12						; size = 4
_nSize$ = 16						; size = 4
_XXTeaDecode PROC					; COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00012	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 136  :     unsigned int p, q ;
; 137  : 	unsigned int e; 
; 138  : 	unsigned int y = v[0];//第一个数

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d d4	 mov	 DWORD PTR _y$[ebp], ecx

; 139  : 	unsigned int sum = 0;

  00026	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _sum$[ebp], 0

; 140  : 	unsigned int len = nSize - 1; 

  0002d	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00030	83 e8 01	 sub	 eax, 1
  00033	89 45 bc	 mov	 DWORD PTR _len$[ebp], eax

; 141  : 	unsigned int z = v[len];//最后一个数

  00036	8b 45 bc	 mov	 eax, DWORD PTR _len$[ebp]
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0003c	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0003f	89 55 b0	 mov	 DWORD PTR _z$[ebp], edx

; 142  : 	
; 143  : 	if (nSize > 1) {

  00042	83 7d 10 01	 cmp	 DWORD PTR _nSize$[ebp], 1
  00046	0f 86 28 01 00
	00		 jbe	 $LN7@XXTeaDecod

; 144  : 		q = 6 + 52 / nSize;

  0004c	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
  00051	33 d2		 xor	 edx, edx
  00053	f7 75 10	 div	 DWORD PTR _nSize$[ebp]
  00056	83 c0 06	 add	 eax, 6
  00059	89 45 ec	 mov	 DWORD PTR _q$[ebp], eax

; 145  : 		sum = q * TEADELTA;

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _q$[ebp]
  0005f	69 c0 b9 79 37
	9e		 imul	 eax, -1640531527	; 9e3779b9H
  00065	89 45 c8	 mov	 DWORD PTR _sum$[ebp], eax
$LN5@XXTeaDecod:

; 146  : 		while (sum != 0) {//q轮加密,这样看起来越短加密轮数越多

  00068	83 7d c8 00	 cmp	 DWORD PTR _sum$[ebp], 0
  0006c	0f 84 02 01 00
	00		 je	 $LN7@XXTeaDecod

; 147  : 			e = (sum >> 2) & 3;

  00072	8b 45 c8	 mov	 eax, DWORD PTR _sum$[ebp]
  00075	c1 e8 02	 shr	 eax, 2
  00078	83 e0 03	 and	 eax, 3
  0007b	89 45 e0	 mov	 DWORD PTR _e$[ebp], eax

; 148  : 			for (p=len; p>0; p--)

  0007e	8b 45 bc	 mov	 eax, DWORD PTR _len$[ebp]
  00081	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax
  00084	eb 09		 jmp	 SHORT $LN3@XXTeaDecod
$LN2@XXTeaDecod:
  00086	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00089	83 e8 01	 sub	 eax, 1
  0008c	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax
$LN3@XXTeaDecod:
  0008f	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp], 0
  00093	76 75		 jbe	 SHORT $LN1@XXTeaDecod

; 149  : 			{
; 150  : 				z = v[p-1],y = v[p] -= MOVOP;

  00095	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00098	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  0009b	8b 54 81 fc	 mov	 edx, DWORD PTR [ecx+eax*4-4]
  0009f	89 55 b0	 mov	 DWORD PTR _z$[ebp], edx
  000a2	8b 45 b0	 mov	 eax, DWORD PTR _z$[ebp]
  000a5	c1 e8 05	 shr	 eax, 5
  000a8	8b 4d d4	 mov	 ecx, DWORD PTR _y$[ebp]
  000ab	c1 e1 02	 shl	 ecx, 2
  000ae	33 c1		 xor	 eax, ecx
  000b0	8b 55 d4	 mov	 edx, DWORD PTR _y$[ebp]
  000b3	c1 ea 03	 shr	 edx, 3
  000b6	8b 4d b0	 mov	 ecx, DWORD PTR _z$[ebp]
  000b9	c1 e1 04	 shl	 ecx, 4
  000bc	33 d1		 xor	 edx, ecx
  000be	03 c2		 add	 eax, edx
  000c0	8b 55 c8	 mov	 edx, DWORD PTR _sum$[ebp]
  000c3	33 55 d4	 xor	 edx, DWORD PTR _y$[ebp]
  000c6	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  000c9	83 e1 03	 and	 ecx, 3
  000cc	33 4d e0	 xor	 ecx, DWORD PTR _e$[ebp]
  000cf	8b 75 08	 mov	 esi, DWORD PTR _context$[ebp]
  000d2	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  000d5	33 4d b0	 xor	 ecx, DWORD PTR _z$[ebp]
  000d8	03 d1		 add	 edx, ecx
  000da	33 c2		 xor	 eax, edx
  000dc	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  000df	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  000e2	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  000e5	2b d0		 sub	 edx, eax
  000e7	89 95 e8 fe ff
	ff		 mov	 DWORD PTR tv130[ebp], edx
  000ed	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  000f0	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  000f3	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv130[ebp]
  000f9	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  000fc	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv130[ebp]
  00102	89 45 d4	 mov	 DWORD PTR _y$[ebp], eax

; 151  : 			}

  00105	e9 7c ff ff ff	 jmp	 $LN2@XXTeaDecod
$LN1@XXTeaDecod:

; 152  : 			z = v[len];

  0010a	8b 45 bc	 mov	 eax, DWORD PTR _len$[ebp]
  0010d	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  00110	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00113	89 55 b0	 mov	 DWORD PTR _z$[ebp], edx

; 153  : 			y = v[0] -= MOVOP;

  00116	8b 45 b0	 mov	 eax, DWORD PTR _z$[ebp]
  00119	c1 e8 05	 shr	 eax, 5
  0011c	8b 4d d4	 mov	 ecx, DWORD PTR _y$[ebp]
  0011f	c1 e1 02	 shl	 ecx, 2
  00122	33 c1		 xor	 eax, ecx
  00124	8b 55 d4	 mov	 edx, DWORD PTR _y$[ebp]
  00127	c1 ea 03	 shr	 edx, 3
  0012a	8b 4d b0	 mov	 ecx, DWORD PTR _z$[ebp]
  0012d	c1 e1 04	 shl	 ecx, 4
  00130	33 d1		 xor	 edx, ecx
  00132	03 c2		 add	 eax, edx
  00134	8b 55 c8	 mov	 edx, DWORD PTR _sum$[ebp]
  00137	33 55 d4	 xor	 edx, DWORD PTR _y$[ebp]
  0013a	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  0013d	83 e1 03	 and	 ecx, 3
  00140	33 4d e0	 xor	 ecx, DWORD PTR _e$[ebp]
  00143	8b 75 08	 mov	 esi, DWORD PTR _context$[ebp]
  00146	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  00149	33 4d b0	 xor	 ecx, DWORD PTR _z$[ebp]
  0014c	03 d1		 add	 edx, ecx
  0014e	33 c2		 xor	 eax, edx
  00150	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  00153	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00155	2b c8		 sub	 ecx, eax
  00157	8b 55 0c	 mov	 edx, DWORD PTR _v$[ebp]
  0015a	89 0a		 mov	 DWORD PTR [edx], ecx
  0015c	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0015f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00161	89 4d d4	 mov	 DWORD PTR _y$[ebp], ecx

; 154  : 			sum -= TEADELTA;

  00164	8b 45 c8	 mov	 eax, DWORD PTR _sum$[ebp]
  00167	05 47 86 c8 61	 add	 eax, 1640531527		; 61c88647H
  0016c	89 45 c8	 mov	 DWORD PTR _sum$[ebp], eax

; 155  : 		}

  0016f	e9 f4 fe ff ff	 jmp	 $LN5@XXTeaDecod
$LN7@XXTeaDecod:

; 156  : 	}
; 157  : }

  00174	5f		 pop	 edi
  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx
  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
_XXTeaDecode ENDP
_TEXT	ENDS
END

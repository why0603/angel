; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\windows\belial\crypt\RC.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__real@4000000000000000
PUBLIC	_RCInit
EXTRN	_memset:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_log:PROC
EXTRN	__fltused:DWORD
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT __real@4000000000000000
; File d:\windows\belial\crypt\rc.c
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT _RCInit
_TEXT	SEGMENT
tv187 = -272						; size = 8
tv185 = -264						; size = 4
tv182 = -258						; size = 2
tv208 = -256						; size = 8
tv171 = -248						; size = 8
_d$ = -44						; size = 4
_c$ = -32						; size = 4
_b$ = -20						; size = 4
_a$ = -8						; size = 4
_pContext$ = 8						; size = 4
_RCInit	PROC						; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-272]
  00012	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 86   : 	unsigned long a = 9990;

  0001e	c7 45 f8 06 27
	00 00		 mov	 DWORD PTR _a$[ebp], 9990 ; 00002706H

; 87   : 	unsigned long b = 8888;

  00025	c7 45 ec b8 22
	00 00		 mov	 DWORD PTR _b$[ebp], 8888 ; 000022b8H

; 88   : 	unsigned long c = 7770;

  0002c	c7 45 e0 5a 1e
	00 00		 mov	 DWORD PTR _c$[ebp], 7770 ; 00001e5aH

; 89   : 	unsigned long d = 6666;

  00033	c7 45 d4 0a 1a
	00 00		 mov	 DWORD PTR _d$[ebp], 6666 ; 00001a0aH

; 90   : 
; 91   : 	if ((pContext->mode <= Rc_Mode_Min) || 
; 92   : 		(pContext->mode >= Rc_Mode_Max))

  0003a	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0003d	83 78 20 ff	 cmp	 DWORD PTR [eax+32], -1
  00041	7e 09		 jle	 SHORT $LN6@RCInit
  00043	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00046	83 78 20 02	 cmp	 DWORD PTR [eax+32], 2
  0004a	7c 0a		 jl	 SHORT $LN7@RCInit
$LN6@RCInit:

; 93   : 	{
; 94   : 		pContext->mode = RC_Mode_RC5;

  0004c	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0004f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
$LN7@RCInit:

; 95   : 	}
; 96   : 
; 97   : 	//本来int类型表示字长,但是在64位下,long才是64位
; 98   : 	//w字长  字节表示
; 99   : 	pContext->nWordSizeByte = GetCpuWordSize(NULL,NULL);//sizeof(long);

  00056	6a 00		 push	 0
  00058	6a 00		 push	 0
  0005a	e8 00 00 00 00	 call	 _GetCpuWordSize
  0005f	83 c4 08	 add	 esp, 8
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  00065	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 100  : 	//CPU大于等于64位时，则按32位算
; 101  : 	//不支持64位
; 102  : 	if (pContext->nWordSizeByte >= 8)

  00068	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0006b	83 78 08 08	 cmp	 DWORD PTR [eax+8], 8
  0006f	72 0a		 jb	 SHORT $LN5@RCInit

; 103  : 	{
; 104  : 		pContext->nWordSizeByte = 4;

  00071	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00074	c7 40 08 04 00
	00 00		 mov	 DWORD PTR [eax+8], 4
$LN5@RCInit:

; 105  : 	}
; 106  : 	//w字长  位表示
; 107  : 	pContext->nWordSizeBit = pContext->nWordSizeByte * 8;

  0007b	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0007e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00081	c1 e1 03	 shl	 ecx, 3
  00084	8b 55 08	 mov	 edx, DWORD PTR _pContext$[ebp]
  00087	89 0a		 mov	 DWORD PTR [edx], ecx

; 108  : 	//r 加密轮数
; 109  : 	if ((pContext->nRound <= 0))

  00089	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0008c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00090	77 0c		 ja	 SHORT $LN4@RCInit

; 110  : 	{
; 111  : 		pContext->nRound = ROUND;

  00092	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00095	c7 40 04 14 00
	00 00		 mov	 DWORD PTR [eax+4], 20	; 00000014H

; 112  : 	}
; 113  : 	else

  0009c	eb 15		 jmp	 SHORT $LN3@RCInit
$LN4@RCInit:

; 114  : 	{
; 115  : 		pContext->nRound = pContext->nRound % MAXROUND;

  0009e	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  000a1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a4	33 d2		 xor	 edx, edx
  000a6	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  000ab	f7 f1		 div	 ecx
  000ad	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  000b0	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN3@RCInit:

; 116  : 	}
; 117  : 	//log2(w)
; 118  : 	pContext->nShiftCount = (unsigned int)(log((long double)pContext->nWordSizeBit) / log((long double)2));

  000b3	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  000b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b8	89 8d 08 ff ff
	ff		 mov	 DWORD PTR tv171[ebp], ecx
  000be	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv171[ebp+4], 0
  000c8	df ad 08 ff ff
	ff		 fild	 QWORD PTR tv171[ebp]
  000ce	83 ec 08	 sub	 esp, 8
  000d1	dd 1c 24	 fstp	 QWORD PTR [esp]
  000d4	e8 00 00 00 00	 call	 _log
  000d9	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4000000000000000
  000df	dd 1c 24	 fstp	 QWORD PTR [esp]
  000e2	dd 9d 00 ff ff
	ff		 fstp	 QWORD PTR tv208[ebp]
  000e8	e8 00 00 00 00	 call	 _log
  000ed	83 c4 08	 add	 esp, 8
  000f0	dc bd 00 ff ff
	ff		 fdivr	 QWORD PTR tv208[ebp]
  000f6	d9 bd fe fe ff
	ff		 fnstcw	 WORD PTR tv182[ebp]
  000fc	0f b7 85 fe fe
	ff ff		 movzx	 eax, WORD PTR tv182[ebp]
  00103	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00108	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv185[ebp], eax
  0010e	d9 ad f8 fe ff
	ff		 fldcw	 WORD PTR tv185[ebp]
  00114	df bd f0 fe ff
	ff		 fistp	 QWORD PTR tv187[ebp]
  0011a	d9 ad fe fe ff
	ff		 fldcw	 WORD PTR tv182[ebp]
  00120	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv187[ebp]
  00126	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00129	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 119  : 
; 120  : 	//pContext->nShiftCount = (unsigned int)(log((long double)pContext->nWordSizeByte) / log((long double)2));
; 121  : 
; 122  : 	if (pContext->mode == RC_Mode_RC5)

  0012c	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0012f	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00133	75 12		 jne	 SHORT $LN2@RCInit

; 123  : 	{
; 124  : 		//分组个数2*r + 2  其中r为加密轮数,单个分组大小为两个字长
; 125  : 		pContext->nSubKeyLen = 2 * pContext->nRound + 2;

  00135	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00138	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013b	8d 54 09 02	 lea	 edx, DWORD PTR [ecx+ecx+2]
  0013f	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00142	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 126  : 	}
; 127  : 	else

  00145	eb 10		 jmp	 SHORT $LN1@RCInit
$LN2@RCInit:

; 128  : 	{
; 129  : 		//分组个数2*r + 2  其中r为加密轮数,单个分组大小为两个字长
; 130  : 		pContext->nSubKeyLen = 2 * pContext->nRound + 3;

  00147	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0014a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0014d	8d 54 09 03	 lea	 edx, DWORD PTR [ecx+ecx+3]
  00151	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00154	89 50 1c	 mov	 DWORD PTR [eax+28], edx
$LN1@RCInit:

; 131  : 	}
; 132  : 		//密文分组  单个密文分组为2*w(字长),使用2*(r + 1)个,r为加密轮数
; 133  : 	pContext->pSubKey = (unsigned long*)malloc(pContext->nSubKeyLen * pContext->nWordSizeByte);

  00157	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0015a	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0015d	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00160	0f af 51 08	 imul	 edx, DWORD PTR [ecx+8]
  00164	8b f4		 mov	 esi, esp
  00166	52		 push	 edx
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0016d	83 c4 04	 add	 esp, 4
  00170	3b f4		 cmp	 esi, esp
  00172	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00177	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0017a	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 134  : 	memset(pContext->pSubKey,0,pContext->nSubKeyLen * pContext->nWordSizeByte);

  0017d	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00180	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  00183	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00186	0f af 51 08	 imul	 edx, DWORD PTR [ecx+8]
  0018a	52		 push	 edx
  0018b	6a 00		 push	 0
  0018d	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00190	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00193	51		 push	 ecx
  00194	e8 00 00 00 00	 call	 _memset
  00199	83 c4 0c	 add	 esp, 12			; 0000000cH

; 135  : 	RCSetKey(pContext);

  0019c	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 _RCSetKey
  001a5	83 c4 04	 add	 esp, 4

; 136  : }

  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5b		 pop	 ebx
  001ab	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  001b1	3b ec		 cmp	 ebp, esp
  001b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
_RCInit	ENDP
_TEXT	ENDS
PUBLIC	_RCDestroy
EXTRN	__imp__free:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _RCDestroy
_TEXT	SEGMENT
_pContext$ = 8						; size = 4
_RCDestroy PROC						; COMDAT

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 140  : 	//销毁子密钥空间
; 141  : 	if ((NULL != pContext) && (NULL != pContext->pSubKey))

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pContext$[ebp], 0
  00022	74 22		 je	 SHORT $LN2@RCDestroy
  00024	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00027	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0002b	74 19		 je	 SHORT $LN2@RCDestroy

; 142  : 	{
; 143  : 		free(pContext->pSubKey);

  0002d	8b f4		 mov	 esi, esp
  0002f	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00032	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0003c	83 c4 04	 add	 esp, 4
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@RCDestroy:

; 144  : 	}
; 145  : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_RCDestroy ENDP
_TEXT	ENDS
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _RCSetKey
_TEXT	SEGMENT
tv149 = -364						; size = 4
tv143 = -364						; size = 4
tv73 = -364						; size = 4
_nSubKeyLen$ = -164					; size = 4
_nLen$ = -152						; size = 4
_pKey$ = -140						; size = 4
_max$ = -128						; size = 4
_q$ = -116						; size = 4
_p$ = -104						; size = 4
_b$ = -92						; size = 4
_a$ = -80						; size = 4
_pL$ = -68						; size = 4
_w$ = -56						; size = 4
_t$ = -44						; size = 4
_k$ = -32						; size = 4
_j$ = -20						; size = 4
_i$ = -8						; size = 4
_pContext$ = 8						; size = 4
_RCSetKey PROC						; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 6c 01 00
	00		 sub	 esp, 364		; 0000016cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 94 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-364]
  00012	b9 5b 00 00 00	 mov	 ecx, 91			; 0000005bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 149  : 	int i;
; 150  : 	unsigned int j,k,t,w;
; 151  : 	unsigned long* pL;
; 152  : 	unsigned long a,b;
; 153  : 	unsigned long p,q;
; 154  : 	unsigned long max;
; 155  : 
; 156  : 	//密钥
; 157  : 	unsigned char* pKey = pContext->pKey;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00021	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00024	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _pKey$[ebp], ecx

; 158  : 
; 159  : 	//密钥长度
; 160  : 	unsigned int nLen = pContext->nKeyLen;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0002d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00030	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _nLen$[ebp], ecx

; 161  : 
; 162  : 	//子密钥组数
; 163  : 	unsigned int nSubKeyLen = pContext->nSubKeyLen;

  00036	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00039	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0003c	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _nSubKeyLen$[ebp], ecx

; 164  : 	//字长
; 165  : 	w = pContext->nWordSizeByte;

  00042	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00045	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00048	89 4d c8	 mov	 DWORD PTR _w$[ebp], ecx

; 166  : 
; 167  : 	//将字符串转化为字长整型需要的个数
; 168  : 	k = (nLen % w == 0) ? (nLen / w) : (nLen / w) + 1;

  0004b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _nLen$[ebp]
  00051	33 d2		 xor	 edx, edx
  00053	f7 75 c8	 div	 DWORD PTR _w$[ebp]
  00056	85 d2		 test	 edx, edx
  00058	75 13		 jne	 SHORT $LN11@RCSetKey
  0005a	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _nLen$[ebp]
  00060	33 d2		 xor	 edx, edx
  00062	f7 75 c8	 div	 DWORD PTR _w$[ebp]
  00065	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
  0006b	eb 14		 jmp	 SHORT $LN12@RCSetKey
$LN11@RCSetKey:
  0006d	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _nLen$[ebp]
  00073	33 d2		 xor	 edx, edx
  00075	f7 75 c8	 div	 DWORD PTR _w$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv73[ebp], eax
$LN12@RCSetKey:
  00081	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv73[ebp]
  00087	89 45 e0	 mov	 DWORD PTR _k$[ebp], eax

; 169  : 
; 170  : 	//总字节数
; 171  : 	t = k * w;

  0008a	8b 45 e0	 mov	 eax, DWORD PTR _k$[ebp]
  0008d	0f af 45 c8	 imul	 eax, DWORD PTR _w$[ebp]
  00091	89 45 d4	 mov	 DWORD PTR _t$[ebp], eax

; 172  : 
; 173  : 	//临时数组，密钥转换成字节长整型
; 174  : 	pL = (unsigned long*)malloc(t);

  00094	8b f4		 mov	 esi, esp
  00096	8b 45 d4	 mov	 eax, DWORD PTR _t$[ebp]
  00099	50		 push	 eax
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000a0	83 c4 04	 add	 esp, 4
  000a3	3b f4		 cmp	 esi, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	89 45 bc	 mov	 DWORD PTR _pL$[ebp], eax

; 175  : 	memset(pL,0,t);

  000ad	8b 45 d4	 mov	 eax, DWORD PTR _t$[ebp]
  000b0	50		 push	 eax
  000b1	6a 00		 push	 0
  000b3	8b 4d bc	 mov	 ecx, DWORD PTR _pL$[ebp]
  000b6	51		 push	 ecx
  000b7	e8 00 00 00 00	 call	 _memset
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 176  : 
; 177  : 	//将字符串数组COPY到新的字长数组(大端法)
; 178  : 	for (i=(nLen-1); i>=0; i--)

  000bf	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _nLen$[ebp]
  000c5	83 e8 01	 sub	 eax, 1
  000c8	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  000cb	eb 09		 jmp	 SHORT $LN8@RCSetKey
$LN7@RCSetKey:
  000cd	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000d0	83 e8 01	 sub	 eax, 1
  000d3	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN8@RCSetKey:
  000d6	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  000da	7c 2f		 jl	 SHORT $LN6@RCSetKey

; 179  : 	{
; 180  : 		pL[i/w] = (pL[i/w] << 8) + pKey[i];

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000df	33 d2		 xor	 edx, edx
  000e1	f7 75 c8	 div	 DWORD PTR _w$[ebp]
  000e4	8b 4d bc	 mov	 ecx, DWORD PTR _pL$[ebp]
  000e7	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  000ea	c1 e1 08	 shl	 ecx, 8
  000ed	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _pKey$[ebp]
  000f3	03 55 f8	 add	 edx, DWORD PTR _i$[ebp]
  000f6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000f9	03 c8		 add	 ecx, eax
  000fb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000fe	33 d2		 xor	 edx, edx
  00100	f7 75 c8	 div	 DWORD PTR _w$[ebp]
  00103	8b 55 bc	 mov	 edx, DWORD PTR _pL$[ebp]
  00106	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx

; 181  : 	}

  00109	eb c2		 jmp	 SHORT $LN7@RCSetKey
$LN6@RCSetKey:

; 182  : 	
; 183  : 	//获取与字长相关的Pw和Qw的值
; 184  : 	SetPwQw(w,&p,&q);

  0010b	8d 45 8c	 lea	 eax, DWORD PTR _q$[ebp]
  0010e	50		 push	 eax
  0010f	8d 4d 98	 lea	 ecx, DWORD PTR _p$[ebp]
  00112	51		 push	 ecx
  00113	8b 55 c8	 mov	 edx, DWORD PTR _w$[ebp]
  00116	52		 push	 edx
  00117	e8 00 00 00 00	 call	 _SetPwQw
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 185  : 
; 186  : 	//初始化subkey
; 187  : 	pContext->pSubKey[0] = p;

  0011f	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00122	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00125	8b 55 98	 mov	 edx, DWORD PTR _p$[ebp]
  00128	89 11		 mov	 DWORD PTR [ecx], edx

; 188  : 	for (i=1; i<nLen; i++)

  0012a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00131	eb 09		 jmp	 SHORT $LN5@RCSetKey
$LN4@RCSetKey:
  00133	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00136	83 c0 01	 add	 eax, 1
  00139	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN5@RCSetKey:
  0013c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0013f	3b 85 68 ff ff
	ff		 cmp	 eax, DWORD PTR _nLen$[ebp]
  00145	73 1e		 jae	 SHORT $LN3@RCSetKey

; 189  : 	{
; 190  : 		pContext->pSubKey[i] = pContext->pSubKey[i-1] + q;

  00147	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0014a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0014d	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00150	8b 44 91 fc	 mov	 eax, DWORD PTR [ecx+edx*4-4]
  00154	03 45 8c	 add	 eax, DWORD PTR _q$[ebp]
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0015a	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0015d	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00160	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 191  : 	}

  00163	eb ce		 jmp	 SHORT $LN4@RCSetKey
$LN3@RCSetKey:

; 192  : 
; 193  : 	//密钥扩展
; 194  : 	a = 0;

  00165	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _a$[ebp], 0

; 195  : 	b = 0;

  0016c	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _b$[ebp], 0

; 196  : 	i = 0;

  00173	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 197  : 	j = 0;

  0017a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 198  : 	//密钥转换之后的长度 和 子密钥的长度
; 199  : 	//字符串长 / 字长       2 * (r + 1) r为加密轮数
; 200  : 	max = (pContext->nSubKeyLen > k) ? pContext->nSubKeyLen : k;

  00181	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00184	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00187	3b 4d e0	 cmp	 ecx, DWORD PTR _k$[ebp]
  0018a	76 0e		 jbe	 SHORT $LN13@RCSetKey
  0018c	8b 55 08	 mov	 edx, DWORD PTR _pContext$[ebp]
  0018f	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00192	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv143[ebp], eax
  00198	eb 09		 jmp	 SHORT $LN14@RCSetKey
$LN13@RCSetKey:
  0019a	8b 4d e0	 mov	 ecx, DWORD PTR _k$[ebp]
  0019d	89 8d 94 fe ff
	ff		 mov	 DWORD PTR tv143[ebp], ecx
$LN14@RCSetKey:
  001a3	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR tv143[ebp]
  001a9	89 55 80	 mov	 DWORD PTR _max$[ebp], edx

; 201  : 	max = 3 * max;

  001ac	8b 45 80	 mov	 eax, DWORD PTR _max$[ebp]
  001af	6b c0 03	 imul	 eax, 3
  001b2	89 45 80	 mov	 DWORD PTR _max$[ebp], eax

; 202  : 	w = 1 << pContext->nShiftCount;//最大移位次数

  001b5	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  001b8	ba 01 00 00 00	 mov	 edx, 1
  001bd	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001c0	d3 e2		 shl	 edx, cl
  001c2	89 55 c8	 mov	 DWORD PTR _w$[ebp], edx
$LN2@RCSetKey:

; 203  : 	//max times
; 204  : 	while (max-- > 0)

  001c5	8b 45 80	 mov	 eax, DWORD PTR _max$[ebp]
  001c8	8b 4d 80	 mov	 ecx, DWORD PTR _max$[ebp]
  001cb	83 e9 01	 sub	 ecx, 1
  001ce	89 4d 80	 mov	 DWORD PTR _max$[ebp], ecx
  001d1	85 c0		 test	 eax, eax
  001d3	76 0c		 jbe	 SHORT $LN15@RCSetKey
  001d5	c7 85 94 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv149[ebp], 1
  001df	eb 0a		 jmp	 SHORT $LN16@RCSetKey
$LN15@RCSetKey:
  001e1	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv149[ebp], 0
$LN16@RCSetKey:
  001eb	83 bd 94 fe ff
	ff 00		 cmp	 DWORD PTR tv149[ebp], 0
  001f2	0f 84 fc 00 00
	00		 je	 $LN1@RCSetKey

; 205  : 	{
; 206  : 		pContext->pSubKey[i] = pContext->pSubKey[i] + a + b;

  001f8	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  001fb	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001fe	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00201	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00204	03 45 b0	 add	 eax, DWORD PTR _a$[ebp]
  00207	03 45 a4	 add	 eax, DWORD PTR _b$[ebp]
  0020a	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0020d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00210	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00213	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 207  : 		pContext->pSubKey[i] = ROTL(pContext->pSubKey[i],3,w);

  00216	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00219	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0021c	8b 55 c8	 mov	 edx, DWORD PTR _w$[ebp]
  0021f	83 ea 01	 sub	 edx, 1
  00222	83 e2 03	 and	 edx, 3
  00225	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00228	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0022b	8b ca		 mov	 ecx, edx
  0022d	d3 e0		 shl	 eax, cl
  0022f	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  00232	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00235	8b 4d c8	 mov	 ecx, DWORD PTR _w$[ebp]
  00238	83 e9 01	 sub	 ecx, 1
  0023b	83 e1 03	 and	 ecx, 3
  0023e	8b 75 c8	 mov	 esi, DWORD PTR _w$[ebp]
  00241	2b f1		 sub	 esi, ecx
  00243	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00246	8b 14 8a	 mov	 edx, DWORD PTR [edx+ecx*4]
  00249	8b ce		 mov	 ecx, esi
  0024b	d3 ea		 shr	 edx, cl
  0024d	0b c2		 or	 eax, edx
  0024f	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  00252	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00255	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00258	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 208  : 		a = pContext->pSubKey[i];

  0025b	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0025e	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00261	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00264	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00267	89 45 b0	 mov	 DWORD PTR _a$[ebp], eax

; 209  : 		pL[j] = pL[j] + a + b;

  0026a	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  0026d	8b 4d bc	 mov	 ecx, DWORD PTR _pL$[ebp]
  00270	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00273	03 55 b0	 add	 edx, DWORD PTR _a$[ebp]
  00276	03 55 a4	 add	 edx, DWORD PTR _b$[ebp]
  00279	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  0027c	8b 4d bc	 mov	 ecx, DWORD PTR _pL$[ebp]
  0027f	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 210  : 		pL[j] = ROTL(pL[j],a+b,w);

  00282	8b 4d b0	 mov	 ecx, DWORD PTR _a$[ebp]
  00285	03 4d a4	 add	 ecx, DWORD PTR _b$[ebp]
  00288	8b 45 c8	 mov	 eax, DWORD PTR _w$[ebp]
  0028b	83 e8 01	 sub	 eax, 1
  0028e	23 c8		 and	 ecx, eax
  00290	8b 55 ec	 mov	 edx, DWORD PTR _j$[ebp]
  00293	8b 45 bc	 mov	 eax, DWORD PTR _pL$[ebp]
  00296	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00299	d3 e2		 shl	 edx, cl
  0029b	8b 45 b0	 mov	 eax, DWORD PTR _a$[ebp]
  0029e	03 45 a4	 add	 eax, DWORD PTR _b$[ebp]
  002a1	8b 4d c8	 mov	 ecx, DWORD PTR _w$[ebp]
  002a4	83 e9 01	 sub	 ecx, 1
  002a7	23 c1		 and	 eax, ecx
  002a9	8b 4d c8	 mov	 ecx, DWORD PTR _w$[ebp]
  002ac	2b c8		 sub	 ecx, eax
  002ae	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  002b1	8b 75 bc	 mov	 esi, DWORD PTR _pL$[ebp]
  002b4	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  002b7	d3 e8		 shr	 eax, cl
  002b9	0b d0		 or	 edx, eax
  002bb	8b 4d ec	 mov	 ecx, DWORD PTR _j$[ebp]
  002be	8b 45 bc	 mov	 eax, DWORD PTR _pL$[ebp]
  002c1	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx

; 211  : 		b = pL[j];

  002c4	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  002c7	8b 4d bc	 mov	 ecx, DWORD PTR _pL$[ebp]
  002ca	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  002cd	89 55 a4	 mov	 DWORD PTR _b$[ebp], edx

; 212  : 		i = (i+1) % nSubKeyLen;

  002d0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  002d3	83 c0 01	 add	 eax, 1
  002d6	33 d2		 xor	 edx, edx
  002d8	f7 b5 5c ff ff
	ff		 div	 DWORD PTR _nSubKeyLen$[ebp]
  002de	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 213  : 		j = (j+1) % k;

  002e1	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  002e4	83 c0 01	 add	 eax, 1
  002e7	33 d2		 xor	 edx, edx
  002e9	f7 75 e0	 div	 DWORD PTR _k$[ebp]
  002ec	89 55 ec	 mov	 DWORD PTR _j$[ebp], edx

; 214  : 	}

  002ef	e9 d1 fe ff ff	 jmp	 $LN2@RCSetKey
$LN1@RCSetKey:

; 215  : 	free(pL);

  002f4	8b f4		 mov	 esi, esp
  002f6	8b 45 bc	 mov	 eax, DWORD PTR _pL$[ebp]
  002f9	50		 push	 eax
  002fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00300	83 c4 04	 add	 esp, 4
  00303	3b f4		 cmp	 esi, esp
  00305	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 216  : }

  0030a	52		 push	 edx
  0030b	8b cd		 mov	 ecx, ebp
  0030d	50		 push	 eax
  0030e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@RCSetKey
  00314	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00319	58		 pop	 eax
  0031a	5a		 pop	 edx
  0031b	5f		 pop	 edi
  0031c	5e		 pop	 esi
  0031d	5b		 pop	 ebx
  0031e	81 c4 6c 01 00
	00		 add	 esp, 364		; 0000016cH
  00324	3b ec		 cmp	 ebp, esp
  00326	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0032b	8b e5		 mov	 esp, ebp
  0032d	5d		 pop	 ebp
  0032e	c3		 ret	 0
  0032f	90		 npad	 1
$LN20@RCSetKey:
  00330	02 00 00 00	 DD	 2
  00334	00 00 00 00	 DD	 $LN19@RCSetKey
$LN19@RCSetKey:
  00338	98 ff ff ff	 DD	 -104			; ffffff98H
  0033c	04 00 00 00	 DD	 4
  00340	00 00 00 00	 DD	 $LN17@RCSetKey
  00344	8c ff ff ff	 DD	 -116			; ffffff8cH
  00348	04 00 00 00	 DD	 4
  0034c	00 00 00 00	 DD	 $LN18@RCSetKey
$LN18@RCSetKey:
  00350	71		 DB	 113			; 00000071H
  00351	00		 DB	 0
$LN17@RCSetKey:
  00352	70		 DB	 112			; 00000070H
  00353	00		 DB	 0
_RCSetKey ENDP
_TEXT	ENDS
PUBLIC	_FR
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _FR
_TEXT	SEGMENT
_tmp$ = -8						; size = 4
_pA$ = 8						; size = 4
_pB$ = 12						; size = 4
_pC$ = 16						; size = 4
_pD$ = 20						; size = 4
_FR	PROC						; COMDAT

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 383  : 	unsigned long tmp = *pD;

  0001e	8b 45 14	 mov	 eax, DWORD PTR _pD$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d f8	 mov	 DWORD PTR _tmp$[ebp], ecx

; 384  : 	*pD = *pC;

  00026	8b 45 14	 mov	 eax, DWORD PTR _pD$[ebp]
  00029	8b 4d 10	 mov	 ecx, DWORD PTR _pC$[ebp]
  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 385  : 	*pC = *pB;

  00030	8b 45 10	 mov	 eax, DWORD PTR _pC$[ebp]
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _pB$[ebp]
  00036	8b 11		 mov	 edx, DWORD PTR [ecx]
  00038	89 10		 mov	 DWORD PTR [eax], edx

; 386  : 	*pB = *pA;

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _pB$[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _pA$[ebp]
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	89 10		 mov	 DWORD PTR [eax], edx

; 387  : 	*pA = tmp;

  00044	8b 45 08	 mov	 eax, DWORD PTR _pA$[ebp]
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _tmp$[ebp]
  0004a	89 08		 mov	 DWORD PTR [eax], ecx

; 388  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_FR	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _GetCpuWordSize
_TEXT	SEGMENT
_offset$ = -8						; size = 4
_pNull1$ = 8						; size = 4
_pNull2$ = 12						; size = 4
_GetCpuWordSize PROC					; COMDAT

; 391  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 392  : 	long offset = (long)&pNull2 - (long)&pNull1;

  0001e	8d 45 0c	 lea	 eax, DWORD PTR _pNull2$[ebp]
  00021	8d 4d 08	 lea	 ecx, DWORD PTR _pNull1$[ebp]
  00024	2b c1		 sub	 eax, ecx
  00026	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax

; 393  : 	return offset;  

  00029	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp]

; 394  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_GetCpuWordSize ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _SetPwQw
_TEXT	SEGMENT
_nWordSize$ = 8						; size = 4
_pPw$ = 12						; size = 4
_pQw$ = 16						; size = 4
_SetPwQw PROC						; COMDAT

; 397  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 398  : 	if (nWordSize == 2)

  0001e	83 7d 08 02	 cmp	 DWORD PTR _nWordSize$[ebp], 2
  00022	75 14		 jne	 SHORT $LN6@SetPwQw

; 399  : 	{
; 400  : 		*pPw = P16;

  00024	8b 45 0c	 mov	 eax, DWORD PTR _pPw$[ebp]
  00027	c7 00 e1 b7 00
	00		 mov	 DWORD PTR [eax], 47073	; 0000b7e1H

; 401  : 		*pQw = Q16;

  0002d	8b 45 10	 mov	 eax, DWORD PTR _pQw$[ebp]
  00030	c7 00 37 9e 00
	00		 mov	 DWORD PTR [eax], 40503	; 00009e37H
  00036	eb 46		 jmp	 SHORT $LN7@SetPwQw
$LN6@SetPwQw:

; 402  : 	}
; 403  : 	else if(nWordSize == 4)

  00038	83 7d 08 04	 cmp	 DWORD PTR _nWordSize$[ebp], 4
  0003c	75 14		 jne	 SHORT $LN4@SetPwQw

; 404  : 	{
; 405  : 		*pPw = P32;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _pPw$[ebp]
  00041	c7 00 63 51 e1
	b7		 mov	 DWORD PTR [eax], -1209970333 ; b7e15163H

; 406  : 		*pQw = Q32;

  00047	8b 45 10	 mov	 eax, DWORD PTR _pQw$[ebp]
  0004a	c7 00 b9 79 37
	9e		 mov	 DWORD PTR [eax], -1640531527 ; 9e3779b9H
  00050	eb 2c		 jmp	 SHORT $LN7@SetPwQw
$LN4@SetPwQw:

; 407  : 	}
; 408  : 	else if(nWordSize == 8)

  00052	83 7d 08 08	 cmp	 DWORD PTR _nWordSize$[ebp], 8
  00056	75 14		 jne	 SHORT $LN2@SetPwQw

; 409  : 	{
; 410  : 		/* 暂时就不要支持64位的吧
; 411  : 			*pPw = P64;
; 412  : 			*pQw = Q64;
; 413  : 		*/
; 414  : 		*pPw = P32;

  00058	8b 45 0c	 mov	 eax, DWORD PTR _pPw$[ebp]
  0005b	c7 00 63 51 e1
	b7		 mov	 DWORD PTR [eax], -1209970333 ; b7e15163H

; 415  : 		*pQw = Q32;

  00061	8b 45 10	 mov	 eax, DWORD PTR _pQw$[ebp]
  00064	c7 00 b9 79 37
	9e		 mov	 DWORD PTR [eax], -1640531527 ; 9e3779b9H

; 416  : 	}
; 417  : 	else

  0006a	eb 12		 jmp	 SHORT $LN7@SetPwQw
$LN2@SetPwQw:

; 418  : 	{
; 419  : 		*pPw = 0;

  0006c	8b 45 0c	 mov	 eax, DWORD PTR _pPw$[ebp]
  0006f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 420  : 		*pQw = 0;

  00075	8b 45 10	 mov	 eax, DWORD PTR _pQw$[ebp]
  00078	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN7@SetPwQw:

; 421  : 	}
; 422  : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_SetPwQw ENDP
_TEXT	ENDS
PUBLIC	_RCEncrypt
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _RCEncrypt
_TEXT	SEGMENT
tv77 = -268						; size = 4
tv71 = -268						; size = 4
_w$ = -68						; size = 4
_nOutputLen$ = -56					; size = 4
_nLen$ = -44						; size = 4
_q$ = -32						; size = 4
_pOutWord$ = -20					; size = 4
_i$ = -8						; size = 4
_pContext$ = 8						; size = 4
_pInput$ = 12						; size = 4
_nSize$ = 16						; size = 4
_pOutput$ = 20						; size = 4
_RCEncrypt PROC						; COMDAT

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 429  : 	unsigned int i;
; 430  : 	unsigned long* pOutWord = (unsigned long*)pOutput;

  0001e	8b 45 14	 mov	 eax, DWORD PTR _pOutput$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR _pOutWord$[ebp], eax

; 431  : 	unsigned int q = 0;

  00024	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _q$[ebp], 0

; 432  : 	unsigned int nLen;
; 433  : 	unsigned int nOutputLen;
; 434  : 	//只支持32位
; 435  : 	unsigned int w = 4;//GetCpuWordSize(NULL,NULL);

  0002b	c7 45 bc 04 00
	00 00		 mov	 DWORD PTR _w$[ebp], 4

; 436  : 	//保证总字节是字长的倍数
; 437  : 	//这里最大字长是4
; 438  : 	//nLen = nSize + (w - (nSize % w));
; 439  : 	//nLen = nSize;
; 440  : 	//rc5一次计算2个字长
; 441  : 	if (pContext->mode == RC_Mode_RC5)

  00032	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00035	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00039	75 32		 jne	 SHORT $LN10@RCEncrypt

; 442  : 	{
; 443  : 		//RC5一次计算两个字长,8个字节
; 444  : 		nLen = CHECKDIV8(nSize);

  0003b	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  0003e	83 e0 07	 and	 eax, 7
  00041	74 16		 je	 SHORT $LN13@RCEncrypt
  00043	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00046	83 c1 08	 add	 ecx, 8
  00049	8b 55 10	 mov	 edx, DWORD PTR _nSize$[ebp]
  0004c	83 e2 07	 and	 edx, 7
  0004f	2b ca		 sub	 ecx, edx
  00051	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv71[ebp], ecx
  00057	eb 09		 jmp	 SHORT $LN14@RCEncrypt
$LN13@RCEncrypt:
  00059	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  0005c	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
$LN14@RCEncrypt:
  00062	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  00068	89 4d d4	 mov	 DWORD PTR _nLen$[ebp], ecx

; 445  : 		//转成字长后的个数
; 446  : 	}
; 447  : 	else

  0006b	eb 30		 jmp	 SHORT $LN9@RCEncrypt
$LN10@RCEncrypt:

; 448  : 	{
; 449  : 		//RC6一次计算4个字长k,16个字节
; 450  : 		nLen = CHECKDIV16(nSize);

  0006d	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00070	83 e0 0f	 and	 eax, 15			; 0000000fH
  00073	74 16		 je	 SHORT $LN15@RCEncrypt
  00075	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00078	83 c1 10	 add	 ecx, 16			; 00000010H
  0007b	8b 55 10	 mov	 edx, DWORD PTR _nSize$[ebp]
  0007e	83 e2 0f	 and	 edx, 15			; 0000000fH
  00081	2b ca		 sub	 ecx, edx
  00083	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv77[ebp], ecx
  00089	eb 09		 jmp	 SHORT $LN16@RCEncrypt
$LN15@RCEncrypt:
  0008b	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  0008e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
$LN16@RCEncrypt:
  00094	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv77[ebp]
  0009a	89 4d d4	 mov	 DWORD PTR _nLen$[ebp], ecx
$LN9@RCEncrypt:

; 451  : 	}
; 452  : 	//补齐到可运算字节数
; 453  : 	//nLen += (nLen % q) == 0 ? 0 : q - (q % 16);
; 454  : 	//字长数
; 455  : 	nOutputLen = nLen / w;

  0009d	8b 45 d4	 mov	 eax, DWORD PTR _nLen$[ebp]
  000a0	33 d2		 xor	 edx, edx
  000a2	f7 75 bc	 div	 DWORD PTR _w$[ebp]
  000a5	89 45 c8	 mov	 DWORD PTR _nOutputLen$[ebp], eax

; 456  : 	//清0
; 457  : 	memset(pOutWord,0,nLen);

  000a8	8b 45 d4	 mov	 eax, DWORD PTR _nLen$[ebp]
  000ab	50		 push	 eax
  000ac	6a 00		 push	 0
  000ae	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 _memset
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 458  : 	//拷贝字节
; 459  : 	memcpy(pOutWord,pInput,nSize);

  000ba	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 0c	 mov	 ecx, DWORD PTR _pInput$[ebp]
  000c1	51		 push	 ecx
  000c2	8b 55 ec	 mov	 edx, DWORD PTR _pOutWord$[ebp]
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 _memcpy
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 460  : 	if (pContext->mode == RC_Mode_RC5)

  000ce	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  000d1	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000d5	75 3f		 jne	 SHORT $LN8@RCEncrypt

; 461  : 	{
; 462  : 		for (i=0; i<nOutputLen; i+=2)

  000d7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000de	eb 09		 jmp	 SHORT $LN7@RCEncrypt
$LN6@RCEncrypt:
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000e3	83 c0 02	 add	 eax, 2
  000e6	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@RCEncrypt:
  000e9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ec	3b 45 c8	 cmp	 eax, DWORD PTR _nOutputLen$[ebp]
  000ef	73 23		 jae	 SHORT $LN5@RCEncrypt

; 463  : 		{
; 464  : 			Encrypt5(pContext,&pOutWord[i],&pOutWord[i+1]);

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f4	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  000f7	8d 54 81 04	 lea	 edx, DWORD PTR [ecx+eax*4+4]
  000fb	52		 push	 edx
  000fc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ff	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  00102	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00105	52		 push	 edx
  00106	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _Encrypt5
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 465  : 		}

  00112	eb cc		 jmp	 SHORT $LN6@RCEncrypt
$LN5@RCEncrypt:

; 466  : 	}
; 467  : 	else

  00114	eb 53		 jmp	 SHORT $LN11@RCEncrypt
$LN8@RCEncrypt:

; 468  : 	{
; 469  : 		for (i=0; i<nOutputLen; i+=4)

  00116	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0011d	eb 09		 jmp	 SHORT $LN3@RCEncrypt
$LN2@RCEncrypt:
  0011f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00122	83 c0 04	 add	 eax, 4
  00125	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@RCEncrypt:
  00128	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0012b	3b 45 c8	 cmp	 eax, DWORD PTR _nOutputLen$[ebp]
  0012e	73 39		 jae	 SHORT $LN11@RCEncrypt

; 470  : 		{
; 471  : 			Encrypt6(pContext,&pOutWord[i],&pOutWord[i+1],&pOutWord[i+2],&pOutWord[i+3]);

  00130	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00133	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  00136	8d 54 81 0c	 lea	 edx, DWORD PTR [ecx+eax*4+12]
  0013a	52		 push	 edx
  0013b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0013e	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  00141	8d 54 81 08	 lea	 edx, DWORD PTR [ecx+eax*4+8]
  00145	52		 push	 edx
  00146	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00149	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  0014c	8d 54 81 04	 lea	 edx, DWORD PTR [ecx+eax*4+4]
  00150	52		 push	 edx
  00151	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00154	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  00157	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0015a	52		 push	 edx
  0015b	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 _Encrypt6
  00164	83 c4 14	 add	 esp, 20			; 00000014H

; 472  : 		}

  00167	eb b6		 jmp	 SHORT $LN2@RCEncrypt
$LN11@RCEncrypt:

; 473  : 	}
; 474  : }

  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00172	3b ec		 cmp	 ebp, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
_RCEncrypt ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _Encrypt5
_TEXT	SEGMENT
_b$ = -44						; size = 4
_a$ = -32						; size = 4
_w$ = -20						; size = 4
_i$ = -8						; size = 4
_pContext$ = 8						; size = 4
_pA$ = 12						; size = 4
_pB$ = 16						; size = 4
_Encrypt5 PROC						; COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 223  : 	unsigned long i,w;
; 224  : 	register unsigned long a = *pA;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _pA$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d e0	 mov	 DWORD PTR _a$[ebp], ecx

; 225  : 	register unsigned long b = *pB;

  00026	8b 45 10	 mov	 eax, DWORD PTR _pB$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 4d d4	 mov	 DWORD PTR _b$[ebp], ecx

; 226  : 	w = pContext->nWordSizeBit;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	89 4d ec	 mov	 DWORD PTR _w$[ebp], ecx

; 227  : 	a += pContext->pSubKey[0];

  00036	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00039	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003c	8b 55 e0	 mov	 edx, DWORD PTR _a$[ebp]
  0003f	03 11		 add	 edx, DWORD PTR [ecx]
  00041	89 55 e0	 mov	 DWORD PTR _a$[ebp], edx

; 228  : 	b += pContext->pSubKey[1];

  00044	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00047	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004a	8b 55 d4	 mov	 edx, DWORD PTR _b$[ebp]
  0004d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00050	89 55 d4	 mov	 DWORD PTR _b$[ebp], edx

; 229  : 	for (i=1; i<=pContext->nRound; i++)

  00053	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0005a	eb 09		 jmp	 SHORT $LN3@Encrypt5
$LN2@Encrypt5:
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0005f	83 c0 01	 add	 eax, 1
  00062	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@Encrypt5:
  00065	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0006b	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0006e	0f 87 8a 00 00
	00		 ja	 $LN1@Encrypt5

; 230  : 	{
; 231  : 		a = ROTL((a ^ b),b,w);

  00074	8b 45 e0	 mov	 eax, DWORD PTR _a$[ebp]
  00077	33 45 d4	 xor	 eax, DWORD PTR _b$[ebp]
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  0007d	83 e9 01	 sub	 ecx, 1
  00080	23 4d d4	 and	 ecx, DWORD PTR _b$[ebp]
  00083	d3 e0		 shl	 eax, cl
  00085	8b 55 e0	 mov	 edx, DWORD PTR _a$[ebp]
  00088	33 55 d4	 xor	 edx, DWORD PTR _b$[ebp]
  0008b	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  0008e	83 e9 01	 sub	 ecx, 1
  00091	23 4d d4	 and	 ecx, DWORD PTR _b$[ebp]
  00094	8b 75 ec	 mov	 esi, DWORD PTR _w$[ebp]
  00097	2b f1		 sub	 esi, ecx
  00099	8b ce		 mov	 ecx, esi
  0009b	d3 ea		 shr	 edx, cl
  0009d	0b c2		 or	 eax, edx
  0009f	89 45 e0	 mov	 DWORD PTR _a$[ebp], eax

; 232  : 		a += pContext->pSubKey[2 * i];

  000a2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000a5	d1 e0		 shl	 eax, 1
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  000aa	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000ad	8b 4d e0	 mov	 ecx, DWORD PTR _a$[ebp]
  000b0	03 0c 82	 add	 ecx, DWORD PTR [edx+eax*4]
  000b3	89 4d e0	 mov	 DWORD PTR _a$[ebp], ecx

; 233  : 		b = ROTL((b ^ a),a,w);

  000b6	8b 45 d4	 mov	 eax, DWORD PTR _b$[ebp]
  000b9	33 45 e0	 xor	 eax, DWORD PTR _a$[ebp]
  000bc	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  000bf	83 e9 01	 sub	 ecx, 1
  000c2	23 4d e0	 and	 ecx, DWORD PTR _a$[ebp]
  000c5	d3 e0		 shl	 eax, cl
  000c7	8b 55 d4	 mov	 edx, DWORD PTR _b$[ebp]
  000ca	33 55 e0	 xor	 edx, DWORD PTR _a$[ebp]
  000cd	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  000d0	83 e9 01	 sub	 ecx, 1
  000d3	23 4d e0	 and	 ecx, DWORD PTR _a$[ebp]
  000d6	8b 75 ec	 mov	 esi, DWORD PTR _w$[ebp]
  000d9	2b f1		 sub	 esi, ecx
  000db	8b ce		 mov	 ecx, esi
  000dd	d3 ea		 shr	 edx, cl
  000df	0b c2		 or	 eax, edx
  000e1	89 45 d4	 mov	 DWORD PTR _b$[ebp], eax

; 234  : 		b += pContext->pSubKey[2 * i + 1];

  000e4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000e7	d1 e0		 shl	 eax, 1
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  000ec	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000ef	8b 4d d4	 mov	 ecx, DWORD PTR _b$[ebp]
  000f2	03 4c 82 04	 add	 ecx, DWORD PTR [edx+eax*4+4]
  000f6	89 4d d4	 mov	 DWORD PTR _b$[ebp], ecx

; 235  : 	}

  000f9	e9 5e ff ff ff	 jmp	 $LN2@Encrypt5
$LN1@Encrypt5:

; 236  : 	*pA = a;

  000fe	8b 45 0c	 mov	 eax, DWORD PTR _pA$[ebp]
  00101	8b 4d e0	 mov	 ecx, DWORD PTR _a$[ebp]
  00104	89 08		 mov	 DWORD PTR [eax], ecx

; 237  : 	*pB = b;

  00106	8b 45 10	 mov	 eax, DWORD PTR _pB$[ebp]
  00109	8b 4d d4	 mov	 ecx, DWORD PTR _b$[ebp]
  0010c	89 08		 mov	 DWORD PTR [eax], ecx

; 238  : }

  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5b		 pop	 ebx
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
_Encrypt5 ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _Encrypt6
_TEXT	SEGMENT
_d$ = -104						; size = 4
_c$ = -92						; size = 4
_b$ = -80						; size = 4
_a$ = -68						; size = 4
_t1$ = -56						; size = 4
_u$ = -44						; size = 4
_t$ = -32						; size = 4
_w$ = -20						; size = 4
_i$ = -8						; size = 4
_pContext$ = 8						; size = 4
_pA$ = 12						; size = 4
_pB$ = 16						; size = 4
_pC$ = 20						; size = 4
_pD$ = 24						; size = 4
_Encrypt6 PROC						; COMDAT

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00012	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 269  : 	unsigned long i,w,t,u,t1;
; 270  : 	register unsigned long a = *pA;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _pA$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d bc	 mov	 DWORD PTR _a$[ebp], ecx

; 271  : 	register unsigned long b = *pB;

  00026	8b 45 10	 mov	 eax, DWORD PTR _pB$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 4d b0	 mov	 DWORD PTR _b$[ebp], ecx

; 272  : 	register unsigned long c = *pC;

  0002e	8b 45 14	 mov	 eax, DWORD PTR _pC$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	89 4d a4	 mov	 DWORD PTR _c$[ebp], ecx

; 273  : 	register unsigned long d = *pD;

  00036	8b 45 18	 mov	 eax, DWORD PTR _pD$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 4d 98	 mov	 DWORD PTR _d$[ebp], ecx

; 274  : 	w = pContext->nWordSizeBit;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	89 4d ec	 mov	 DWORD PTR _w$[ebp], ecx

; 275  : 	b += pContext->pSubKey[0];

  00046	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00049	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004c	8b 55 b0	 mov	 edx, DWORD PTR _b$[ebp]
  0004f	03 11		 add	 edx, DWORD PTR [ecx]
  00051	89 55 b0	 mov	 DWORD PTR _b$[ebp], edx

; 276  : 	d += pContext->pSubKey[1];

  00054	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00057	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005a	8b 55 98	 mov	 edx, DWORD PTR _d$[ebp]
  0005d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00060	89 55 98	 mov	 DWORD PTR _d$[ebp], edx

; 277  : 	for (i=1; i<=pContext->nRound; i++)

  00063	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  0006a	eb 09		 jmp	 SHORT $LN3@Encrypt6
$LN2@Encrypt6:
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@Encrypt6:
  00075	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00078	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0007b	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0007e	0f 87 1c 01 00
	00		 ja	 $LN1@Encrypt6

; 278  : 	{
; 279  : 		//根据b计算u的值
; 280  : 		t = b * (2 * b + 1);

  00084	8b 45 b0	 mov	 eax, DWORD PTR _b$[ebp]
  00087	8d 4c 00 01	 lea	 ecx, DWORD PTR [eax+eax+1]
  0008b	0f af 4d b0	 imul	 ecx, DWORD PTR _b$[ebp]
  0008f	89 4d e0	 mov	 DWORD PTR _t$[ebp], ecx

; 281  : 		t = ROTL(t,pContext->nShiftCount,w);

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  00095	83 e9 01	 sub	 ecx, 1
  00098	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0009b	23 48 14	 and	 ecx, DWORD PTR [eax+20]
  0009e	8b 55 e0	 mov	 edx, DWORD PTR _t$[ebp]
  000a1	d3 e2		 shl	 edx, cl
  000a3	8b 45 ec	 mov	 eax, DWORD PTR _w$[ebp]
  000a6	83 e8 01	 sub	 eax, 1
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  000ac	23 41 14	 and	 eax, DWORD PTR [ecx+20]
  000af	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  000b2	2b c8		 sub	 ecx, eax
  000b4	8b 45 e0	 mov	 eax, DWORD PTR _t$[ebp]
  000b7	d3 e8		 shr	 eax, cl
  000b9	0b d0		 or	 edx, eax
  000bb	89 55 e0	 mov	 DWORD PTR _t$[ebp], edx

; 282  : 		//根据d计算u的值
; 283  : 		u = d * (2 * d + 1);

  000be	8b 45 98	 mov	 eax, DWORD PTR _d$[ebp]
  000c1	8d 4c 00 01	 lea	 ecx, DWORD PTR [eax+eax+1]
  000c5	0f af 4d 98	 imul	 ecx, DWORD PTR _d$[ebp]
  000c9	89 4d d4	 mov	 DWORD PTR _u$[ebp], ecx

; 284  : 		u = ROTL(u,pContext->nShiftCount,w);

  000cc	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  000cf	83 e9 01	 sub	 ecx, 1
  000d2	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  000d5	23 48 14	 and	 ecx, DWORD PTR [eax+20]
  000d8	8b 55 d4	 mov	 edx, DWORD PTR _u$[ebp]
  000db	d3 e2		 shl	 edx, cl
  000dd	8b 45 ec	 mov	 eax, DWORD PTR _w$[ebp]
  000e0	83 e8 01	 sub	 eax, 1
  000e3	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  000e6	23 41 14	 and	 eax, DWORD PTR [ecx+20]
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  000ec	2b c8		 sub	 ecx, eax
  000ee	8b 45 d4	 mov	 eax, DWORD PTR _u$[ebp]
  000f1	d3 e8		 shr	 eax, cl
  000f3	0b d0		 or	 edx, eax
  000f5	89 55 d4	 mov	 DWORD PTR _u$[ebp], edx

; 285  : 		
; 286  : 		a = ROTL((a ^ t),u,w);

  000f8	8b 45 bc	 mov	 eax, DWORD PTR _a$[ebp]
  000fb	33 45 e0	 xor	 eax, DWORD PTR _t$[ebp]
  000fe	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  00101	83 e9 01	 sub	 ecx, 1
  00104	23 4d d4	 and	 ecx, DWORD PTR _u$[ebp]
  00107	d3 e0		 shl	 eax, cl
  00109	8b 55 bc	 mov	 edx, DWORD PTR _a$[ebp]
  0010c	33 55 e0	 xor	 edx, DWORD PTR _t$[ebp]
  0010f	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  00112	83 e9 01	 sub	 ecx, 1
  00115	23 4d d4	 and	 ecx, DWORD PTR _u$[ebp]
  00118	8b 75 ec	 mov	 esi, DWORD PTR _w$[ebp]
  0011b	2b f1		 sub	 esi, ecx
  0011d	8b ce		 mov	 ecx, esi
  0011f	d3 ea		 shr	 edx, cl
  00121	0b c2		 or	 eax, edx
  00123	89 45 bc	 mov	 DWORD PTR _a$[ebp], eax

; 287  : 		a = a + pContext->pSubKey[2 * i];

  00126	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00129	d1 e0		 shl	 eax, 1
  0012b	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0012e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00131	8b 4d bc	 mov	 ecx, DWORD PTR _a$[ebp]
  00134	03 0c 82	 add	 ecx, DWORD PTR [edx+eax*4]
  00137	89 4d bc	 mov	 DWORD PTR _a$[ebp], ecx

; 288  : 		c = ROTL((c ^ u),t,w);

  0013a	8b 45 a4	 mov	 eax, DWORD PTR _c$[ebp]
  0013d	33 45 d4	 xor	 eax, DWORD PTR _u$[ebp]
  00140	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  00143	83 e9 01	 sub	 ecx, 1
  00146	23 4d e0	 and	 ecx, DWORD PTR _t$[ebp]
  00149	d3 e0		 shl	 eax, cl
  0014b	8b 55 a4	 mov	 edx, DWORD PTR _c$[ebp]
  0014e	33 55 d4	 xor	 edx, DWORD PTR _u$[ebp]
  00151	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  00154	83 e9 01	 sub	 ecx, 1
  00157	23 4d e0	 and	 ecx, DWORD PTR _t$[ebp]
  0015a	8b 75 ec	 mov	 esi, DWORD PTR _w$[ebp]
  0015d	2b f1		 sub	 esi, ecx
  0015f	8b ce		 mov	 ecx, esi
  00161	d3 ea		 shr	 edx, cl
  00163	0b c2		 or	 eax, edx
  00165	89 45 a4	 mov	 DWORD PTR _c$[ebp], eax

; 289  : 		c = c + pContext->pSubKey[2 * i + 1];

  00168	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0016b	d1 e0		 shl	 eax, 1
  0016d	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  00170	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00173	8b 4d a4	 mov	 ecx, DWORD PTR _c$[ebp]
  00176	03 4c 82 04	 add	 ecx, DWORD PTR [edx+eax*4+4]
  0017a	89 4d a4	 mov	 DWORD PTR _c$[ebp], ecx

; 290  : 		//置换
; 291  : 		//printf("i=%d,%u,%u,%u,%u,%u,%u\r\n",i,a,b,c,d,t,u);
; 292  : 		///*
; 293  : 		t1 = a;

  0017d	8b 45 bc	 mov	 eax, DWORD PTR _a$[ebp]
  00180	89 45 c8	 mov	 DWORD PTR _t1$[ebp], eax

; 294  : 		a = b;

  00183	8b 45 b0	 mov	 eax, DWORD PTR _b$[ebp]
  00186	89 45 bc	 mov	 DWORD PTR _a$[ebp], eax

; 295  : 		b = c;

  00189	8b 45 a4	 mov	 eax, DWORD PTR _c$[ebp]
  0018c	89 45 b0	 mov	 DWORD PTR _b$[ebp], eax

; 296  : 		c = d;

  0018f	8b 45 98	 mov	 eax, DWORD PTR _d$[ebp]
  00192	89 45 a4	 mov	 DWORD PTR _c$[ebp], eax

; 297  : 		d = t1;

  00195	8b 45 c8	 mov	 eax, DWORD PTR _t1$[ebp]
  00198	89 45 98	 mov	 DWORD PTR _d$[ebp], eax

; 298  : 		//*/
; 299  : 	}

  0019b	e9 cc fe ff ff	 jmp	 $LN2@Encrypt6
$LN1@Encrypt6:

; 300  : 	//printf("-------------------------------------\r\n");
; 301  : 	//按照rc5算法分布的密钥,2*r+2已经到达数组末尾
; 302  : 	//表示rc6最少要比rc5再多产生一组密钥
; 303  : 	a += pContext->pSubKey[2 * pContext->nRound + 2];

  001a0	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  001a3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001a6	d1 e1		 shl	 ecx, 1
  001a8	8b 55 08	 mov	 edx, DWORD PTR _pContext$[ebp]
  001ab	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001ae	8b 55 bc	 mov	 edx, DWORD PTR _a$[ebp]
  001b1	03 54 88 08	 add	 edx, DWORD PTR [eax+ecx*4+8]
  001b5	89 55 bc	 mov	 DWORD PTR _a$[ebp], edx

; 304  : 	c += pContext->pSubKey[2 * pContext->nRound + 3];

  001b8	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  001bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001be	d1 e1		 shl	 ecx, 1
  001c0	8b 55 08	 mov	 edx, DWORD PTR _pContext$[ebp]
  001c3	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  001c6	8b 55 a4	 mov	 edx, DWORD PTR _c$[ebp]
  001c9	03 54 88 0c	 add	 edx, DWORD PTR [eax+ecx*4+12]
  001cd	89 55 a4	 mov	 DWORD PTR _c$[ebp], edx

; 305  : 	*pA = a;

  001d0	8b 45 0c	 mov	 eax, DWORD PTR _pA$[ebp]
  001d3	8b 4d bc	 mov	 ecx, DWORD PTR _a$[ebp]
  001d6	89 08		 mov	 DWORD PTR [eax], ecx

; 306  : 	*pB = b;

  001d8	8b 45 10	 mov	 eax, DWORD PTR _pB$[ebp]
  001db	8b 4d b0	 mov	 ecx, DWORD PTR _b$[ebp]
  001de	89 08		 mov	 DWORD PTR [eax], ecx

; 307  : 	*pC = c;

  001e0	8b 45 14	 mov	 eax, DWORD PTR _pC$[ebp]
  001e3	8b 4d a4	 mov	 ecx, DWORD PTR _c$[ebp]
  001e6	89 08		 mov	 DWORD PTR [eax], ecx

; 308  : 	*pD = d;

  001e8	8b 45 18	 mov	 eax, DWORD PTR _pD$[ebp]
  001eb	8b 4d 98	 mov	 ecx, DWORD PTR _d$[ebp]
  001ee	89 08		 mov	 DWORD PTR [eax], ecx

; 309  : }

  001f0	5f		 pop	 edi
  001f1	5e		 pop	 esi
  001f2	5b		 pop	 ebx
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
_Encrypt6 ENDP
_TEXT	ENDS
PUBLIC	_RCDecrypt
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _RCDecrypt
_TEXT	SEGMENT
tv77 = -268						; size = 4
tv71 = -268						; size = 4
_w$ = -68						; size = 4
_nOutputLen$ = -56					; size = 4
_nLen$ = -44						; size = 4
_q$ = -32						; size = 4
_pOutWord$ = -20					; size = 4
_i$ = -8						; size = 4
_pContext$ = 8						; size = 4
_pInput$ = 12						; size = 4
_nSize$ = 16						; size = 4
_pOutput$ = 20						; size = 4
_RCDecrypt PROC						; COMDAT

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-268]
  00012	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 481  : 	unsigned int i;
; 482  : 	unsigned long* pOutWord = (unsigned long*)pOutput;

  0001e	8b 45 14	 mov	 eax, DWORD PTR _pOutput$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR _pOutWord$[ebp], eax

; 483  : 	unsigned int q = 0;

  00024	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _q$[ebp], 0

; 484  : 	unsigned int nLen;
; 485  : 	unsigned int nOutputLen;
; 486  : 	//只支持32位
; 487  : 	unsigned int w = 4;//GetCpuWordSize(NULL,NULL);

  0002b	c7 45 bc 04 00
	00 00		 mov	 DWORD PTR _w$[ebp], 4

; 488  : 	//保证总字节是字长的倍数
; 489  : 	//这里最大字长是4
; 490  : 	//nLen = nSize + (w - (nSize % w));
; 491  : 	//nLen = nSize;
; 492  : 	//rc5一次计算2个字长
; 493  : 	if (pContext->mode == RC_Mode_RC5)

  00032	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00035	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00039	75 32		 jne	 SHORT $LN10@RCDecrypt

; 494  : 	{
; 495  : 		//RC5一次计算两个字长,8个字节
; 496  : 		nLen = CHECKDIV8(nSize);

  0003b	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  0003e	83 e0 07	 and	 eax, 7
  00041	74 16		 je	 SHORT $LN13@RCDecrypt
  00043	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00046	83 c1 08	 add	 ecx, 8
  00049	8b 55 10	 mov	 edx, DWORD PTR _nSize$[ebp]
  0004c	83 e2 07	 and	 edx, 7
  0004f	2b ca		 sub	 ecx, edx
  00051	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv71[ebp], ecx
  00057	eb 09		 jmp	 SHORT $LN14@RCDecrypt
$LN13@RCDecrypt:
  00059	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  0005c	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
$LN14@RCDecrypt:
  00062	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv71[ebp]
  00068	89 4d d4	 mov	 DWORD PTR _nLen$[ebp], ecx

; 497  : 		//转成字长后的个数
; 498  : 	}
; 499  : 	else

  0006b	eb 30		 jmp	 SHORT $LN9@RCDecrypt
$LN10@RCDecrypt:

; 500  : 	{
; 501  : 		//RC6一次计算4个字长k,16个字节
; 502  : 		nLen = CHECKDIV16(nSize);

  0006d	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  00070	83 e0 0f	 and	 eax, 15			; 0000000fH
  00073	74 16		 je	 SHORT $LN15@RCDecrypt
  00075	8b 4d 10	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00078	83 c1 10	 add	 ecx, 16			; 00000010H
  0007b	8b 55 10	 mov	 edx, DWORD PTR _nSize$[ebp]
  0007e	83 e2 0f	 and	 edx, 15			; 0000000fH
  00081	2b ca		 sub	 ecx, edx
  00083	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv77[ebp], ecx
  00089	eb 09		 jmp	 SHORT $LN16@RCDecrypt
$LN15@RCDecrypt:
  0008b	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  0008e	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
$LN16@RCDecrypt:
  00094	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv77[ebp]
  0009a	89 4d d4	 mov	 DWORD PTR _nLen$[ebp], ecx
$LN9@RCDecrypt:

; 503  : 	}
; 504  : 	//补齐到可运算字节数
; 505  : 	//nLen += (nLen % q) == 0 ? 0 : q - (q % 16);
; 506  : 	//字长数
; 507  : 	nOutputLen = nLen / w;

  0009d	8b 45 d4	 mov	 eax, DWORD PTR _nLen$[ebp]
  000a0	33 d2		 xor	 edx, edx
  000a2	f7 75 bc	 div	 DWORD PTR _w$[ebp]
  000a5	89 45 c8	 mov	 DWORD PTR _nOutputLen$[ebp], eax

; 508  : 	//清0
; 509  : 	memset(pOutWord,0,nLen);

  000a8	8b 45 d4	 mov	 eax, DWORD PTR _nLen$[ebp]
  000ab	50		 push	 eax
  000ac	6a 00		 push	 0
  000ae	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 _memset
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 510  : 	//拷贝字节
; 511  : 	memcpy(pOutWord,pInput,nSize);

  000ba	8b 45 10	 mov	 eax, DWORD PTR _nSize$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 0c	 mov	 ecx, DWORD PTR _pInput$[ebp]
  000c1	51		 push	 ecx
  000c2	8b 55 ec	 mov	 edx, DWORD PTR _pOutWord$[ebp]
  000c5	52		 push	 edx
  000c6	e8 00 00 00 00	 call	 _memcpy
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 512  : 	if (pContext->mode == RC_Mode_RC5)

  000ce	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  000d1	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000d5	75 3f		 jne	 SHORT $LN8@RCDecrypt

; 513  : 	{
; 514  : 		for (i=0; i<nOutputLen; i+=2)

  000d7	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000de	eb 09		 jmp	 SHORT $LN7@RCDecrypt
$LN6@RCDecrypt:
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000e3	83 c0 02	 add	 eax, 2
  000e6	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN7@RCDecrypt:
  000e9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ec	3b 45 c8	 cmp	 eax, DWORD PTR _nOutputLen$[ebp]
  000ef	73 23		 jae	 SHORT $LN5@RCDecrypt

; 515  : 		{
; 516  : 			Decrypt5(pContext,&pOutWord[i],&pOutWord[i+1]);

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f4	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  000f7	8d 54 81 04	 lea	 edx, DWORD PTR [ecx+eax*4+4]
  000fb	52		 push	 edx
  000fc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ff	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  00102	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00105	52		 push	 edx
  00106	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 _Decrypt5
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 517  : 		}

  00112	eb cc		 jmp	 SHORT $LN6@RCDecrypt
$LN5@RCDecrypt:

; 518  : 	}
; 519  : 	else

  00114	eb 53		 jmp	 SHORT $LN11@RCDecrypt
$LN8@RCDecrypt:

; 520  : 	{
; 521  : 		for (i=0; i<nOutputLen; i+=4)

  00116	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0011d	eb 09		 jmp	 SHORT $LN3@RCDecrypt
$LN2@RCDecrypt:
  0011f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00122	83 c0 04	 add	 eax, 4
  00125	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@RCDecrypt:
  00128	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0012b	3b 45 c8	 cmp	 eax, DWORD PTR _nOutputLen$[ebp]
  0012e	73 39		 jae	 SHORT $LN11@RCDecrypt

; 522  : 		{
; 523  : 			Decrypt6(pContext,&pOutWord[i],&pOutWord[i+1],&pOutWord[i+2],&pOutWord[i+3]);

  00130	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00133	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  00136	8d 54 81 0c	 lea	 edx, DWORD PTR [ecx+eax*4+12]
  0013a	52		 push	 edx
  0013b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0013e	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  00141	8d 54 81 08	 lea	 edx, DWORD PTR [ecx+eax*4+8]
  00145	52		 push	 edx
  00146	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00149	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  0014c	8d 54 81 04	 lea	 edx, DWORD PTR [ecx+eax*4+4]
  00150	52		 push	 edx
  00151	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00154	8b 4d ec	 mov	 ecx, DWORD PTR _pOutWord$[ebp]
  00157	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0015a	52		 push	 edx
  0015b	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 _Decrypt6
  00164	83 c4 14	 add	 esp, 20			; 00000014H

; 524  : 		}

  00167	eb b6		 jmp	 SHORT $LN2@RCDecrypt
$LN11@RCDecrypt:

; 525  : 	}
; 526  : }

  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  00172	3b ec		 cmp	 ebp, esp
  00174	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
_RCDecrypt ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _Decrypt5
_TEXT	SEGMENT
_b$ = -44						; size = 4
_a$ = -32						; size = 4
_w$ = -20						; size = 4
_i$ = -8						; size = 4
_pContext$ = 8						; size = 4
_pA$ = 12						; size = 4
_pB$ = 16						; size = 4
_Decrypt5 PROC						; COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 245  : 	unsigned long i,w;
; 246  : 	register unsigned long a = *pA;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _pA$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d e0	 mov	 DWORD PTR _a$[ebp], ecx

; 247  : 	register unsigned long b = *pB;

  00026	8b 45 10	 mov	 eax, DWORD PTR _pB$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 4d d4	 mov	 DWORD PTR _b$[ebp], ecx

; 248  : 	w = pContext->nWordSizeBit;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	89 4d ec	 mov	 DWORD PTR _w$[ebp], ecx

; 249  : 	for (i=pContext->nRound; i>=1; i--)

  00036	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  0003f	eb 09		 jmp	 SHORT $LN3@Decrypt5
$LN2@Decrypt5:
  00041	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00044	83 e8 01	 sub	 eax, 1
  00047	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@Decrypt5:
  0004a	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  0004e	0f 82 84 00 00
	00		 jb	 $LN1@Decrypt5

; 250  : 	{
; 251  : 		b -= pContext->pSubKey[2 * i + 1];

  00054	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00057	d1 e0		 shl	 eax, 1
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0005c	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0005f	8b 4d d4	 mov	 ecx, DWORD PTR _b$[ebp]
  00062	2b 4c 82 04	 sub	 ecx, DWORD PTR [edx+eax*4+4]
  00066	89 4d d4	 mov	 DWORD PTR _b$[ebp], ecx

; 252  : 		b = ROTR(b,a,w) ^ a;

  00069	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  0006c	83 e9 01	 sub	 ecx, 1
  0006f	23 4d e0	 and	 ecx, DWORD PTR _a$[ebp]
  00072	8b 45 d4	 mov	 eax, DWORD PTR _b$[ebp]
  00075	d3 e8		 shr	 eax, cl
  00077	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  0007a	83 e9 01	 sub	 ecx, 1
  0007d	23 4d e0	 and	 ecx, DWORD PTR _a$[ebp]
  00080	8b 55 ec	 mov	 edx, DWORD PTR _w$[ebp]
  00083	2b d1		 sub	 edx, ecx
  00085	8b 75 d4	 mov	 esi, DWORD PTR _b$[ebp]
  00088	8b ca		 mov	 ecx, edx
  0008a	d3 e6		 shl	 esi, cl
  0008c	0b c6		 or	 eax, esi
  0008e	33 45 e0	 xor	 eax, DWORD PTR _a$[ebp]
  00091	89 45 d4	 mov	 DWORD PTR _b$[ebp], eax

; 253  : 		a -= pContext->pSubKey[2 * i];

  00094	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00097	d1 e0		 shl	 eax, 1
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0009c	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR _a$[ebp]
  000a2	2b 0c 82	 sub	 ecx, DWORD PTR [edx+eax*4]
  000a5	89 4d e0	 mov	 DWORD PTR _a$[ebp], ecx

; 254  : 		a = ROTR(a,b,w) ^ b;

  000a8	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  000ab	83 e9 01	 sub	 ecx, 1
  000ae	23 4d d4	 and	 ecx, DWORD PTR _b$[ebp]
  000b1	8b 45 e0	 mov	 eax, DWORD PTR _a$[ebp]
  000b4	d3 e8		 shr	 eax, cl
  000b6	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  000b9	83 e9 01	 sub	 ecx, 1
  000bc	23 4d d4	 and	 ecx, DWORD PTR _b$[ebp]
  000bf	8b 55 ec	 mov	 edx, DWORD PTR _w$[ebp]
  000c2	2b d1		 sub	 edx, ecx
  000c4	8b 75 e0	 mov	 esi, DWORD PTR _a$[ebp]
  000c7	8b ca		 mov	 ecx, edx
  000c9	d3 e6		 shl	 esi, cl
  000cb	0b c6		 or	 eax, esi
  000cd	33 45 d4	 xor	 eax, DWORD PTR _b$[ebp]
  000d0	89 45 e0	 mov	 DWORD PTR _a$[ebp], eax

; 255  : 	}

  000d3	e9 69 ff ff ff	 jmp	 $LN2@Decrypt5
$LN1@Decrypt5:

; 256  : 	a -= pContext->pSubKey[0];

  000d8	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  000db	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000de	8b 55 e0	 mov	 edx, DWORD PTR _a$[ebp]
  000e1	2b 11		 sub	 edx, DWORD PTR [ecx]
  000e3	89 55 e0	 mov	 DWORD PTR _a$[ebp], edx

; 257  : 	b -= pContext->pSubKey[1];

  000e6	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  000e9	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000ec	8b 55 d4	 mov	 edx, DWORD PTR _b$[ebp]
  000ef	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  000f2	89 55 d4	 mov	 DWORD PTR _b$[ebp], edx

; 258  : 	*pA = a;

  000f5	8b 45 0c	 mov	 eax, DWORD PTR _pA$[ebp]
  000f8	8b 4d e0	 mov	 ecx, DWORD PTR _a$[ebp]
  000fb	89 08		 mov	 DWORD PTR [eax], ecx

; 259  : 	*pB = b;

  000fd	8b 45 10	 mov	 eax, DWORD PTR _pB$[ebp]
  00100	8b 4d d4	 mov	 ecx, DWORD PTR _b$[ebp]
  00103	89 08		 mov	 DWORD PTR [eax], ecx

; 260  : }

  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
_Decrypt5 ENDP
; Function compile flags: /Odtp /RTCsu /ZI
_TEXT	ENDS
;	COMDAT _Decrypt6
_TEXT	SEGMENT
_d$ = -104						; size = 4
_c$ = -92						; size = 4
_b$ = -80						; size = 4
_a$ = -68						; size = 4
_t1$ = -56						; size = 4
_u$ = -44						; size = 4
_t$ = -32						; size = 4
_w$ = -20						; size = 4
_i$ = -8						; size = 4
_pContext$ = 8						; size = 4
_pA$ = 12						; size = 4
_pB$ = 16						; size = 4
_pC$ = 20						; size = 4
_pD$ = 24						; size = 4
_Decrypt6 PROC						; COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00012	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 318  : 	unsigned long i,w,t,u,t1;
; 319  : 	register unsigned long a = *pA;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _pA$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d bc	 mov	 DWORD PTR _a$[ebp], ecx

; 320  : 	register unsigned long b = *pB;

  00026	8b 45 10	 mov	 eax, DWORD PTR _pB$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 4d b0	 mov	 DWORD PTR _b$[ebp], ecx

; 321  : 	register unsigned long c = *pC;

  0002e	8b 45 14	 mov	 eax, DWORD PTR _pC$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	89 4d a4	 mov	 DWORD PTR _c$[ebp], ecx

; 322  : 	register unsigned long d = *pD;

  00036	8b 45 18	 mov	 eax, DWORD PTR _pD$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 4d 98	 mov	 DWORD PTR _d$[ebp], ecx

; 323  : 	w = pContext->nWordSizeBit;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	89 4d ec	 mov	 DWORD PTR _w$[ebp], ecx

; 324  : 	c -= pContext->pSubKey[2 * pContext->nRound + 3];

  00046	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00049	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004c	d1 e1		 shl	 ecx, 1
  0004e	8b 55 08	 mov	 edx, DWORD PTR _pContext$[ebp]
  00051	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00054	8b 55 a4	 mov	 edx, DWORD PTR _c$[ebp]
  00057	2b 54 88 0c	 sub	 edx, DWORD PTR [eax+ecx*4+12]
  0005b	89 55 a4	 mov	 DWORD PTR _c$[ebp], edx

; 325  : 	a -= pContext->pSubKey[2 * pContext->nRound + 2];

  0005e	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00061	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00064	d1 e1		 shl	 ecx, 1
  00066	8b 55 08	 mov	 edx, DWORD PTR _pContext$[ebp]
  00069	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0006c	8b 55 bc	 mov	 edx, DWORD PTR _a$[ebp]
  0006f	2b 54 88 08	 sub	 edx, DWORD PTR [eax+ecx*4+8]
  00073	89 55 bc	 mov	 DWORD PTR _a$[ebp], edx

; 326  : 	for (i=pContext->nRound; i>=1; i--)

  00076	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00079	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007c	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  0007f	eb 09		 jmp	 SHORT $LN3@Decrypt6
$LN2@Decrypt6:
  00081	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00084	83 e8 01	 sub	 eax, 1
  00087	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@Decrypt6:
  0008a	83 7d f8 01	 cmp	 DWORD PTR _i$[ebp], 1
  0008e	0f 82 22 01 00
	00		 jb	 $LN1@Decrypt6

; 327  : 	{
; 328  : 		//printf("i=%d,%u,%u,%u,%u\r\n",i,a,b,c,d);
; 329  : 		//逆置换
; 330  : 		//FR(&a,&b,&c,&d);
; 331  : 		///*
; 332  : 		t1 = d;

  00094	8b 45 98	 mov	 eax, DWORD PTR _d$[ebp]
  00097	89 45 c8	 mov	 DWORD PTR _t1$[ebp], eax

; 333  : 		d = c;

  0009a	8b 45 a4	 mov	 eax, DWORD PTR _c$[ebp]
  0009d	89 45 98	 mov	 DWORD PTR _d$[ebp], eax

; 334  : 		c = b;

  000a0	8b 45 b0	 mov	 eax, DWORD PTR _b$[ebp]
  000a3	89 45 a4	 mov	 DWORD PTR _c$[ebp], eax

; 335  : 		b = a;

  000a6	8b 45 bc	 mov	 eax, DWORD PTR _a$[ebp]
  000a9	89 45 b0	 mov	 DWORD PTR _b$[ebp], eax

; 336  : 		a = t1;

  000ac	8b 45 c8	 mov	 eax, DWORD PTR _t1$[ebp]
  000af	89 45 bc	 mov	 DWORD PTR _a$[ebp], eax

; 337  : 		//*/
; 338  : 		//计算u的值,移位数;加密时使用d做为唯一参与计算的数
; 339  : 		u = d * (2 * d + 1);

  000b2	8b 45 98	 mov	 eax, DWORD PTR _d$[ebp]
  000b5	8d 4c 00 01	 lea	 ecx, DWORD PTR [eax+eax+1]
  000b9	0f af 4d 98	 imul	 ecx, DWORD PTR _d$[ebp]
  000bd	89 4d d4	 mov	 DWORD PTR _u$[ebp], ecx

; 340  : 		u = ROTL(u,pContext->nShiftCount,w);

  000c0	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  000c3	83 e9 01	 sub	 ecx, 1
  000c6	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  000c9	23 48 14	 and	 ecx, DWORD PTR [eax+20]
  000cc	8b 55 d4	 mov	 edx, DWORD PTR _u$[ebp]
  000cf	d3 e2		 shl	 edx, cl
  000d1	8b 45 ec	 mov	 eax, DWORD PTR _w$[ebp]
  000d4	83 e8 01	 sub	 eax, 1
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  000da	23 41 14	 and	 eax, DWORD PTR [ecx+20]
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  000e0	2b c8		 sub	 ecx, eax
  000e2	8b 45 d4	 mov	 eax, DWORD PTR _u$[ebp]
  000e5	d3 e8		 shr	 eax, cl
  000e7	0b d0		 or	 edx, eax
  000e9	89 55 d4	 mov	 DWORD PTR _u$[ebp], edx

; 341  : 
; 342  : 		//根据b计算t的值
; 343  : 		t = b * (2 * b + 1);

  000ec	8b 45 b0	 mov	 eax, DWORD PTR _b$[ebp]
  000ef	8d 4c 00 01	 lea	 ecx, DWORD PTR [eax+eax+1]
  000f3	0f af 4d b0	 imul	 ecx, DWORD PTR _b$[ebp]
  000f7	89 4d e0	 mov	 DWORD PTR _t$[ebp], ecx

; 344  : 		t = ROTL(t,pContext->nShiftCount,w);

  000fa	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  000fd	83 e9 01	 sub	 ecx, 1
  00100	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  00103	23 48 14	 and	 ecx, DWORD PTR [eax+20]
  00106	8b 55 e0	 mov	 edx, DWORD PTR _t$[ebp]
  00109	d3 e2		 shl	 edx, cl
  0010b	8b 45 ec	 mov	 eax, DWORD PTR _w$[ebp]
  0010e	83 e8 01	 sub	 eax, 1
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  00114	23 41 14	 and	 eax, DWORD PTR [ecx+20]
  00117	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  0011a	2b c8		 sub	 ecx, eax
  0011c	8b 45 e0	 mov	 eax, DWORD PTR _t$[ebp]
  0011f	d3 e8		 shr	 eax, cl
  00121	0b d0		 or	 edx, eax
  00123	89 55 e0	 mov	 DWORD PTR _t$[ebp], edx

; 345  : 		
; 346  : 		//printf("i=%d,%u,%u,%u,%u,%u,%u\r\n",i,a,b,c,d,t,u);
; 347  : 		c -= pContext->pSubKey[2 * i + 1];

  00126	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00129	d1 e0		 shl	 eax, 1
  0012b	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  0012e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00131	8b 4d a4	 mov	 ecx, DWORD PTR _c$[ebp]
  00134	2b 4c 82 04	 sub	 ecx, DWORD PTR [edx+eax*4+4]
  00138	89 4d a4	 mov	 DWORD PTR _c$[ebp], ecx

; 348  : 		c = ROTR((c),t,w);

  0013b	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  0013e	83 e9 01	 sub	 ecx, 1
  00141	23 4d e0	 and	 ecx, DWORD PTR _t$[ebp]
  00144	8b 45 a4	 mov	 eax, DWORD PTR _c$[ebp]
  00147	d3 e8		 shr	 eax, cl
  00149	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  0014c	83 e9 01	 sub	 ecx, 1
  0014f	23 4d e0	 and	 ecx, DWORD PTR _t$[ebp]
  00152	8b 55 ec	 mov	 edx, DWORD PTR _w$[ebp]
  00155	2b d1		 sub	 edx, ecx
  00157	8b 75 a4	 mov	 esi, DWORD PTR _c$[ebp]
  0015a	8b ca		 mov	 ecx, edx
  0015c	d3 e6		 shl	 esi, cl
  0015e	0b c6		 or	 eax, esi
  00160	89 45 a4	 mov	 DWORD PTR _c$[ebp], eax

; 349  : 		c ^= u;

  00163	8b 45 a4	 mov	 eax, DWORD PTR _c$[ebp]
  00166	33 45 d4	 xor	 eax, DWORD PTR _u$[ebp]
  00169	89 45 a4	 mov	 DWORD PTR _c$[ebp], eax

; 350  : 		a -= pContext->pSubKey[2 * i];

  0016c	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0016f	d1 e0		 shl	 eax, 1
  00171	8b 4d 08	 mov	 ecx, DWORD PTR _pContext$[ebp]
  00174	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00177	8b 4d bc	 mov	 ecx, DWORD PTR _a$[ebp]
  0017a	2b 0c 82	 sub	 ecx, DWORD PTR [edx+eax*4]
  0017d	89 4d bc	 mov	 DWORD PTR _a$[ebp], ecx

; 351  : 		a = ROTR((a),u,w);

  00180	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  00183	83 e9 01	 sub	 ecx, 1
  00186	23 4d d4	 and	 ecx, DWORD PTR _u$[ebp]
  00189	8b 45 bc	 mov	 eax, DWORD PTR _a$[ebp]
  0018c	d3 e8		 shr	 eax, cl
  0018e	8b 4d ec	 mov	 ecx, DWORD PTR _w$[ebp]
  00191	83 e9 01	 sub	 ecx, 1
  00194	23 4d d4	 and	 ecx, DWORD PTR _u$[ebp]
  00197	8b 55 ec	 mov	 edx, DWORD PTR _w$[ebp]
  0019a	2b d1		 sub	 edx, ecx
  0019c	8b 75 bc	 mov	 esi, DWORD PTR _a$[ebp]
  0019f	8b ca		 mov	 ecx, edx
  001a1	d3 e6		 shl	 esi, cl
  001a3	0b c6		 or	 eax, esi
  001a5	89 45 bc	 mov	 DWORD PTR _a$[ebp], eax

; 352  : 		a ^= t;

  001a8	8b 45 bc	 mov	 eax, DWORD PTR _a$[ebp]
  001ab	33 45 e0	 xor	 eax, DWORD PTR _t$[ebp]
  001ae	89 45 bc	 mov	 DWORD PTR _a$[ebp], eax

; 353  : 	}

  001b1	e9 cb fe ff ff	 jmp	 $LN2@Decrypt6
$LN1@Decrypt6:

; 354  : 	//printf("=============================================\r\n");
; 355  : 	//按照rc5算法分布的密钥,2*r+2已经到达数组末尾
; 356  : 	//表示rc6最少要比rc5再多产生一组密钥
; 357  : 	d -= pContext->pSubKey[1];

  001b6	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  001b9	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001bc	8b 55 98	 mov	 edx, DWORD PTR _d$[ebp]
  001bf	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  001c2	89 55 98	 mov	 DWORD PTR _d$[ebp], edx

; 358  : 	b -= pContext->pSubKey[0];

  001c5	8b 45 08	 mov	 eax, DWORD PTR _pContext$[ebp]
  001c8	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  001cb	8b 55 b0	 mov	 edx, DWORD PTR _b$[ebp]
  001ce	2b 11		 sub	 edx, DWORD PTR [ecx]
  001d0	89 55 b0	 mov	 DWORD PTR _b$[ebp], edx

; 359  : 	*pA = a;

  001d3	8b 45 0c	 mov	 eax, DWORD PTR _pA$[ebp]
  001d6	8b 4d bc	 mov	 ecx, DWORD PTR _a$[ebp]
  001d9	89 08		 mov	 DWORD PTR [eax], ecx

; 360  : 	*pB = b;

  001db	8b 45 10	 mov	 eax, DWORD PTR _pB$[ebp]
  001de	8b 4d b0	 mov	 ecx, DWORD PTR _b$[ebp]
  001e1	89 08		 mov	 DWORD PTR [eax], ecx

; 361  : 	*pC = c;

  001e3	8b 45 14	 mov	 eax, DWORD PTR _pC$[ebp]
  001e6	8b 4d a4	 mov	 ecx, DWORD PTR _c$[ebp]
  001e9	89 08		 mov	 DWORD PTR [eax], ecx

; 362  : 	*pD = d;

  001eb	8b 45 18	 mov	 eax, DWORD PTR _pD$[ebp]
  001ee	8b 4d 98	 mov	 ecx, DWORD PTR _d$[ebp]
  001f1	89 08		 mov	 DWORD PTR [eax], ecx

; 363  : }

  001f3	5f		 pop	 edi
  001f4	5e		 pop	 esi
  001f5	5b		 pop	 ebx
  001f6	8b e5		 mov	 esp, ebp
  001f8	5d		 pop	 ebp
  001f9	c3		 ret	 0
_Decrypt6 ENDP
_TEXT	ENDS
END

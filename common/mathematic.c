/******************************************************************************************
 * @file mathematic.c
 * @anthor:Croky.Zheng
 * @CreateTime:2010-05-31
 * @descirption:用于一些C标准库没有自带，或者不能满足需求的数学计算函数
 *****************************************************************************************/
#include "mathematic.h"

//0表示序号对应的1的个数为奇数，这里0表示为偶数
//1表示序号对应的1的个数为偶数
//11001110,有5个1，则奇偶校验为0，偶数个1则为1
static const int double_bit_byte[256] = {
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,
	1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1
};

static const int double_bit_num[128] = {
	0,3,5,6,9,10,12,15,17,18,20,23,24,27,29,30,
	33,34,36,39,40,43,45,46,48,51,53,54,57,58,60,63,
	65,66,68,71,72,75,77,78,80,83,85,86,89,90,92,95,
	96,99,101,102,105,106,108,111,113,114,116,119,120,123,125,126,
	129,130,132,135,136,139,141,142,144,147,149,150,153,154,156,159,
	160,163,165,166,169,170,172,175,177,178,180,183,184,187,189,190,
	192,195,197,198,201,202,204,207,209,210,212,215,216,219,221,222,
	225,226,228,231,232,235,237,238,240,243,245,246,249,250,252,255,
};
/**************************************************************
 * 根据定律:任何整数都可以转变为如下形式：
 *	2^a+2^b+2^c.....
 * 当然，原文是说任何质数（素数）
 * 但是任何数都有2进制形式，2进制到10进制转换就是如上公式
 * 因此，任何数的次方，都可以书写成：
 * N(2^a)*N(2^b)*N(2^c)........的形式
 * 这里，以N的338次方来比例：
 *	0		0		1		0		1	 0		1		0		0		1		0
 * 1024		512		256		128		64	 32		16		8		4		2		1
 * N^1024	N^512	N^256	N^128	N^64 N^32	N^16	N^8		N^4		N^2		N^1
 * 要求N^338其实是求(N^256)*(N^64)*(N^16)*(N^2)
 * 而
 * N		*		N		=		N(2)
 * N^2		*		N^2		=		N(4)
 * N^4		*		N^4		=		N(8)
 * N^8		*		N^8		=		N(16)
 *....以此类推，完全可以根据2进制信息来计算乘方
 */
UINT64 Pow(int x,int y)
{
	if (y == 0)//任何数的0次方等于1
	{
		return 1;
	}
	else if (y < 0)//这样有点不对，当X为0-1时，值是可以为正整数的，但是这里排除这种可能
	{
		return 0;
	}
	else
	{
		UINT64 r = 1; //ret为计算的结果
		UINT64 j = x;//最后一个N^k(K为y的2进制最后一个1对应的乘方积)
		while (y > 1)//这里就不用计算了
		{
			if ((y & 1) == 1)//最后一位为1，表示需要将N的k次方相乘了
			{
				r *= j;
			}
			j *= j; // 主体乘方
			y >>= 1; //右移一位,表示乘积已经产生或者验证是否还需要继续
		 }
		return j * r; // 最后把主体和“剩下的”乘起来作为结果
	}
}

/**
 * 费马小定理
 * 有N为任意正整数，P为素数，且N不能被P整除（显然N和P互质），则有：(P > N)
 * N^P%P=N  即可推理出  N^(p-1) % p = 1
 * (X*Y)%P = ((X%P)*(Y%P))%P
 * 这里不根据上面的Power函数来计算，完全是为了能够计算更大的值
 */
int	PowMod(int x,int y,int m)
{
	if (y == 0) 
	{
		return 1;
	}
	else if (y < 0) 
	{
		return 0;
	}
	else
	{
		UINT64 r = 1; //ret为计算的结果
		UINT64 j = x % m;//最后一个N^k(K为y的2进制最后一个1对应的乘方积)
		while (y > 1)//这里就不用计算了
		{
			if ((y & 1) == 1)//最后一位为1，表示需要将N的k次方相乘了
			{
				r = (r * j) % m;
			}
			j = (j * j) % m; // 主体乘方
			y >>= 1; //右移一位,表示乘积已经产生或者验证是否还需要继续
		 }
		return (j * r) % m; // 最后把主体和“剩下的”乘起来作为结果
	}
}

BOOL IsDoubleBitByByte(BYTE b)
{
	return double_bit_byte[b];
}

BOOL IsDoubleBitByInt(INT n)
{
	int* pNum = &n;
	PBYTE pByteNum = (PBYTE)pNum;
	int cnt = 0;
	//偶数+2   奇数+1
	cnt += (IsDoubleBitByByte(pByteNum[0]) ? 2 : 1);
	cnt += (IsDoubleBitByByte(pByteNum[1]) ? 2 : 1);
	cnt += (IsDoubleBitByByte(pByteNum[2]) ? 2 : 1);
	cnt += (IsDoubleBitByByte(pByteNum[3]) ? 2 : 1);
	return (BOOL)(cnt % 2);
}